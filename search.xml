<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[图文解析HTMLElement.offsetHeight,scrollHeight,clientHeight]]></title>
      <url>%2F2017%2F06%2F05%2FHTMLElement-offsetHeight-scrollHeight-clientHeight%2F</url>
      <content type="text"><![CDATA[HTMLElement.offsetHeight是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 通常，元素的offsetHeight是一种衡量标准，包括元素的边框、垂直内边距和元素的水平滚动条（如果存在且渲染的话）和元素的CSS高度。 对于文档的主体对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。 Element.scrollHeightElement.scrollHeight 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的margin. Element.clientHeight返回元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。 clientHeight 可以通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算. 也就是说，是没有垂直滚动条版本的scrollHeight。 更新： clientWidth = width + padding clientHeight = height + padding offsetWidth = width + padding + border offsetHeight = height + padding + border]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac使用tree]]></title>
      <url>%2F2017%2F05%2F30%2Fmac%E4%BD%BF%E7%94%A8tree%2F</url>
      <content type="text"><![CDATA[一、brew安装1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 然后一直按return键即可 二、brew使用brew安装套件： $ brew install tree 常用命令$ tree -a //显示所有文件和目录。 $ tree -d //显示目录名称而非内容 $ tree -L 2 //这个命令是比较实用的，后面的数字2代表几层]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2写单页面项目总结记录]]></title>
      <url>%2F2017%2F05%2F29%2Fpost%E7%94%A8vue%E5%86%99webapp%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%971%2F</url>
      <content type="text"><![CDATA[前言一直想做个有数据内容的项目，刚好vue社区提供了API，在此感谢。这是一个基于vue+vue-cli+vue-router+axios+webpack开发的vue社区SPA;UI用Muse-UI;css用scss，flex布局，rem做移动端适配，最终效果web端移动端都适配。 如果你和我一样用vue还挺生疏的，那好好做完这个项目，会学到很多东西，能有挺大的进步，一起(๑•̀ㅂ•́)و✧加油。 如果对您有帮助，请给一个star鼓励一下萌新，感谢 ^ ^ 效果预览 github项目地址 项目API 完成功能 首页列表 下拉加载 用户信息（点击头像） 主题内容 登录功能 收藏（取消收藏）主题 评论列表 点赞（取消点赞）功能 消息中心（已读、未读） 个人中心 todo功能 发表评论 回复评论 发布主题（支持markdown格式） 准备开发环境 $ npm install -g vue-cli $ vue init webpack vue-home ? Project name vue-home ? Project description vue-home ? Author afei ? Vue build standalone ? Install vue-router? Yes ? Use ESLint to lint your code? No ? Setup unit tests with Karma + Mocha? No ? Setup e2e tests with Nightwatch? No $ cd vue-home $ npm install $ npm run dev等写完项目后 $ npm run build 注意：npm run dev 之后 默认浏览器打开的是http://localhost:8080 请换成http://localhost:8080/vue-home/dist如果你电脑的8080端口被占用，请congfig/index.js中找到port: 8080修改成8081或者其他可用的端口 开始动手（我会根据每个文件来讲解）项目结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546├── build│ ├── build.js│ ├── check-versions.js│ ├── dev-client.js│ ├── dev-server.js│ ├── utils.js│ ├── vue-loader.conf.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── dist //等写完项目后 $ npm run build 的打包文件│ ├── index.html│ └── static├── index.html //首页入口文件├── node_modules├── package.json ├── src│ ├── App.vue //项目入口文件│ ├── assets│ │ ├── 1495982696.png //手机扫描二维码│ │ ├── logo.png //vue logo│ │ └── sass //sass通用样式│ ├── components //组件│ │ ├── FooterNav.vue //底部nav组件│ │ ├── HeaderBar.vue //顶部横条│ │ ├── HeaderTabs.vue //顶部tabs组件&amp;主页面内容拉取│ │ └── Hello.vue │ ├── main.js //核心文件 在这里引入了Muse UI 时间过滤器│ ├── pages //页面│ │ ├── content.vue //帖子内容页面 │ │ ├── index.vue //首页│ │ ├── login.vue //登录页面│ │ ├── message.vue //信息通知页面│ │ ├── more.vue │ │ ├── my.vue //个人信息页面│ │ ├── people.vue //社区用户信息页面│ │ └── publish.vue //发布帖子页面(此页面还没写完)│ ├── router //路由与组件配置│ │ └── index.js │ └── util //时间过滤器，转换时间格式│ └── filter.js└── static vue-home/config/index.js assetsPublicPath: &#39;/vue-home/dist&#39; 这个公共路径原本为assetsPublicPath: ‘/‘，这样在本地服务器是可以跑，可是打包上传到github后会发现打开的页面是空白的，报错如下图。 原因是路径错了，vue-home是项目文件夹名称，dist是npm run build之后出现的文件夹，github上线就是读取dist文件夹而生成的网页（成功展示的demo地址长这样：http://www.hxvin.me/vue-home/dist/） 解决上线路径问题不知道还有没有其他更方便的解决方法，如果有，请跟我讲下哦 port: 8080 这个是让你改端口的 vue-home/src/App.vue rem适配移动端，1rem=10px 1234html&#123; font-size: 62.5%; &#125; 建议注释掉这段，不然会然干扰后面的css 123/*text-align: center;*//*color: #2c3e50;margin-top: 60px;*/ /vue-home/index.html图 我们是做的移动端，适配web端，所以在index.html里面加上meta 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=0&quot;&gt; 用MuseUI的添加之一 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot;&gt; vue-home/src/main.js 图中有标识了哪些是用来干嘛的，分别是用MuseUI的添加之一；filters是用来把社区api数据中的时间格式转换成*分钟前``*小时前``*天前 未完待续。。。。。。（代码好像用文章不方便介绍，我还是写好代码注释好了哦）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS函数方法坑与填坑]]></title>
      <url>%2F2017%2F05%2F17%2FJS%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%9D%91%E4%B8%8E%E5%A1%AB%E5%9D%91%2F</url>
      <content type="text"><![CDATA[首先，先认识下什么叫函数的方法：在一个对象中绑定函数，称为这个对象的方法。 再给具体的例子：1234567891011var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 27 xiaoming是一个对象，age（）函数就是该对象的方法。此时this指向xiaoming 如果拆开写：123456789101112131415function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: getAge&#125;;xiaoming.age(); // 27, 正常结果getAge(); // NaNvar fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 以对象的方法形式调用没问题，该函数的this指向被调用的对象xiaomign； 你会发现单独调用getAge()函数返回NaN,该函数的this指向全局对象，也就是window，这是JS的一个坑。 填坑：1. 要保证this指向正确，必须用obj.xxx()的形式调用！这里需注意：obj.xxx()也不是什么情况下都适用的，比如在在函数内定义的函数： 1234567891011121314151617181920212223242526272829303132&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property &apos;birth&apos; of undefined填坑：&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 27 2.或者用apply()和call()方法修复函数调用：函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。如：12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2的todolist入门小项目的详细解析]]></title>
      <url>%2F2017%2F05%2F09%2Fvue2%E7%9A%84todolist%E5%85%A5%E9%97%A8%E5%B0%8F%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[看完vue2的官方文档后，找个入门项目巩固下知识点，简单的todolsit是个不错的选择。项目用到了vue.js vue.cli webpack ES6 node环境，完成项目后会对这些技术栈有了些了解。 准备开发环境 $ npm install -g vue-cli $ vue init ，比如 vue init webpack todolist $ cd todolist $ npm install $ npm run dev 安装谷歌插件vue.js devtools 下载vue.js的webpack模板 下载 todomvc的模板 (提供html和css)（也可以直接$ git clone https://github.com/tastejs/todomvc-app-template.git 来下载） 把todomvc的index.html拖到todolist文件夹去覆盖里面的index.html 打开todomvc的json文件，会看到 “todomvc-app-css”: “^2.0.0”,就是要你 npm install todomvc-app-css -S 从而下载该css 删点todolsit index.html的默认css，js引用，src文件夹下的main.js引入模板css（import‘todomvc-app-css/index.css’） 引入vue（import Vue form ‘vue’） 等写完代码后 $npm run build 一键打包构建，会看到dist文件夹 main.js的代码 //后面的为注释讲解， ~表示串联index.html的对应内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import &apos;todomvc-app-css/index.css&apos;import Vue from &apos;vue&apos;//添加localStoragevar STORAGE_KEY = &apos;todos-vuejs-2.0&apos;var todoStorage = &#123; fetch: function () &#123; var todos = JSON.parse(localStorage.getItem(STORAGE_KEY) || &apos;[]&apos;) todos.forEach(function (todo, index) &#123; todo.id = index &#125;) todoStorage.uid = todos.length return todos &#125;, save: function (todos) &#123; localStorage.setItem(STORAGE_KEY, JSON.stringify(todos)) &#125;&#125;//用过滤器筛选出三种状态var filters = &#123; all(todos) &#123; return todos &#125;, active(todos) &#123; return todos.filter((todo) =&gt; &#123; return !todo.completed &#125;) &#125;, completed(todos) &#123; return todos.filter((todo) =&gt; &#123; return todo.completed &#125;) &#125;,&#125;let app = new Vue(&#123; el: &apos;.todoapp&apos;, // ~ &lt;section class=&quot;todoapp&quot;&gt; data: &#123; msg: &apos;hello world&apos;, title: &apos;待做清单&apos;, // 渲染标题 ~ &#123;&#123;title&#125;&#125; newTodo: &apos;&apos;, todos: todoStorage.fetch(), // ~ v-show=&quot;todos.length&quot; ； ~ &#123;&#123;todos.length&gt;1?&apos;items&apos;:&apos;item&apos;&#125;&#125; 渲染 li ~ v-for=&quot;(todo,index) in filteredTodos&quot; editedTodo: &apos;&apos;, // 空的编辑对象 hashName: &apos;all&apos; &#125;, watch: &#123; todos: &#123; handler: function (todos) &#123; todoStorage.save(todos) &#125;, deep: true &#125; &#125;, computed: &#123; remain() &#123; return filters.active(this.todos).length //未完成事项的数量 ~ &#123;&#123;remain&#125;&#125; &#125;, isAll: &#123; // ~ v-model=&quot;isAll&quot; get() &#123; return this.remain === 0 &#125;, set(value) &#123; this.todos.forEach((todo) =&gt; &#123; todo.completed = value &#125;) &#125; &#125;, filteredTodos() &#123; //用hashName过滤出当前页面的todos ~ v-for=&quot;(todo,index) in filteredTodos&quot; return filters[this.hashName](this.todos) &#125; &#125;, methods: &#123; addTodo(e) &#123; //输入值为空时，不添加（trim去除前后空格） ~ v-model.trim=&quot;newTodo&quot; if (!this.newTodo) &#123; return &#125; this.todos.push(&#123; id: todoStorage.uid++, content: this.newTodo, completed: false //结合v-model 根据completed状态绑定样式 ~:class=&quot;&#123;completed:todo.completed； ~ v-model=&quot;todo.completed&quot; &#125;) this.newTodo = &apos;&apos; &#125;, removeTodo(index) &#123; //绑定x样式，点击删除该todo ~ @click=&quot;removeTodo(index)&quot; this.todos.splice(index, 1) &#125;, editTodo(todo) &#123; //编辑 ~ @dblclick=&quot;editTodo(todo)&quot; this.editCache = todo.content //储存编辑前的内容 this.editedTodo = todo // 点击编辑里面的内容而不是只是空文本框~ editing:todo==editedTodo&#125;&quot; &#125;, doneEdit(todo, index) &#123; //失去焦点后 ~ @blur=&quot;doneEdit(todo)&quot;；@keyup.enter=&quot;doneEdit(todo)&quot; this.editedTodo = null //不存在编辑了或者说编辑已完成 if (!todo.content) &#123; //如果编辑后没有内容了，删除该todo this.removeTodo(index) &#125; &#125;, cancelEdit(todo) &#123; //按esc键取消此次编辑操作 ~ @keyup.esc=&quot;cancelEdit(todo)&quot;&gt; this.editedTodo = null todo.content = this.editCache //当esc取消编辑时，还原编辑前的内容 &#125;, clear() &#123; //点击清除已完成的功能 ~ @click=&quot;clear&quot; this.todos = filters.active(this.todos) //获取并渲染未完成的事项 ~ &#125; &#125;, directives: &#123; //自定义属性 ~ v-focus=&quot;todo == editedTodo&quot; focus(el, value) &#123; //文本框双击获取焦点 if (value) &#123; el.focus() &#125; &#125; &#125;&#125;)//hash（url地址中#以及之后的字符）function hashChange() &#123; // ~ :class=&quot;&#123;selected:hashName==&apos;all&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;active&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;completed&apos;&#125;&quot; let hashName = location.hash.replace(/#\/?/, &apos;&apos;) //正则表达式去除#/？，获取如all，active，completed if (filters[hashName]) &#123; //如果过滤状态的hashName存在 app.hashName = hashName //给整个app变量里的hashName赋上那个值 &#125; else &#123; location.hash = &apos;&apos; //取消 app.hashName = &apos;all&apos; //否则就赋值‘all’，回到全部事项的页面 &#125;&#125;window.addEventListener(&apos;hashchange&apos;, hashChange) //全局监听hash]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue学习]]></title>
      <url>%2F2017%2F05%2F08%2FVue%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[此文章用来不断记录Vue学习过程中一知半解知识点的总结，fighting~ 组件：可以扩展 HTML 元素，封装可重用的代码 理解父组件，子组件 v-model：使用 v-model 来进行数据双向绑定，根据控件类型自动选取正确的方法来更新元素，负责监听用户的输入事件以更新数据 理解数据单向绑定，双向绑定 钩子： hook形象解释 生命周期： 生命周期形象解释]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>%2F2017%2F04%2F29%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最好的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算因此很多现代的算法教科书避免使用冒泡排序，而用插入排序替换之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最好的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。 冒泡排序算法的运作如下：（两个for循环差不多搞定） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。 12345678910111213141516function bubbleSort(arr)&#123;if(arr.length&lt;=1)&#123; return arr; &#125; for(var j=0;j&lt;arr.length;j++)&#123; for( var i = 0; i&lt;arr.length-j;i++)&#123; if(arr[i] &gt; arr[i+1])&#123; var num = arr[i]; arr[i] = arr[i+1]; arr[i+1] = num; &#125; &#125; &#125; return arr; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[轻松学习JS快速排序(QuickSort)]]></title>
      <url>%2F2017%2F04%2F29%2F%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0JS%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort%2F</url>
      <content type="text"><![CDATA[需了解的基础知识 1.递归函数：编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。 一个典型阶乘递归函数： 1234567function fact(num)&#123; if (num&lt;=1)&#123; return 1; &#125;else&#123; return num*fact(num-1); &#125; &#125; 该函数的弊端： 123var another=factorical;factorical=null;console.log(another(2))//会报错说 factorical not a function 解决方法: 用arguments.callee去代替函数名，就可以确保函数不管怎么调用都不会出错。 1234567891011function factorical(num)&#123; if(num&lt;=1)&#123; return 1; &#125; else&#123; return num*arguments.callee(num-1); &#125;&#125;var another=factorical;factorical=null;console.log(another(2))//2 (来自js高程) 2.JavaScript中的splice方法用法详解 3.JavaScript concat()方法 3.Javascript之Math对象详解 步骤以下内容整理自阮一峰老师的快速排序（Quicksort）的Javascript实现 首先，定义一个quickSort函数，它的参数是一个数组。 var quickSort = function(arr) { 然后，检查数组的元素个数，如果小于等于1，就返回。 if (arr.length &lt;= 1) { return arr; } 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1); var left = []; var right = []; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。 for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } 最后，使用递归不断重复这个过程，就可以得到排序后的数组。 return quickSort(left).concat([pivot], quickSort(right));}; 使用的时候，直接调用quickSort()就行了。 最终的快排函数123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1); var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 实例运用12var array = [7,4,1,9,6,3,2,5,8] ;quickSort(array); //输出1，2，3，4，5，6，7，8，9]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发中js数组的常用方法]]></title>
      <url>%2F2017%2F04%2F27%2F%E5%BC%80%E5%8F%91%E4%B8%ADjs%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在ES5中，一共有9个Array方法： Array.prototype.indexOf;Array.prototype.lastIndexOf;Array.prototype.every;Array.prototype.some;Array.prototype.forEach;Array.prototype.map;Array.prototype.filter;Array.prototype.reduce;Array.prototype.reduceRight; 5种比较常用=&gt;index(),filter(),forEach(),map(),reduce(). ps:reduce()还没搞懂，就先不整理了。文末有个实例了解实际运用。 介绍1) indexOfindexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。不使用indexOf时： 123456789var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],found = false; for(var i= 0, l = arr.length; i&lt; l; i++)&#123;if(arr[i] === &apos;a&apos;)&#123;found = true;&#125;&#125;console.log(&quot;found:&quot;,found);//输出found: true indexOf使用后 123var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; console.log(&quot;found:&quot;, arr.indexOf(&quot;a&quot;) != -1);//输出found: true 2) filter该filter()方法创建一个新的匹配过滤条件的数组。 不用 filter() 时 12345678910111213141516var arr = [ [&quot;a&quot;, 2], [&quot;b&quot;, 5], [&quot;c&quot;, 3], [&quot;b&quot;, 16],]; var newArr = []; for(var i= 0, l = arr.length; i&lt; l; i++)&#123; if(arr[i][0] == &quot;b&quot; )&#123;newArr.push(arr[i]);&#125;&#125; alert(newArr);//输出b,5,b,16 用了 filter(): 1234567891011var arr = [ [&quot;a&quot;, 2], [&quot;b&quot;, 5], [&quot;c&quot;, 3], [&quot;b&quot;, 16],]; var newArr = arr.filter(function(element, index, array)&#123; return element[0] == &quot;b&quot; ;&#125;); alert(newArr); //输出b,5,b,16 3) forEach()forEach为每个元素执行对应的方法,用来替换for循环 不用 forEach() 时 1234var arr = [1,2,3,4,5,6,7,8];for(var i= 0, l = arr.length; i&lt; l; i++)&#123;console.log(arr[i]); //输出 1 2 3 4 5 6 7 8 &#125; 用了forEach() 1234var arr = [1,2,3,4,5,6,7,8];arr.forEach(function(element, index, array)&#123;console.log(element);//输出 1 2 3 4 5 6 7 8 &#125;); 4) map()map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组，不使用mapmap()是处理服务器返回数据时是一个非常实用的函数。 不用 map() 时 12345678910111213141516var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;]; function getNewArr()&#123; var newArr = []; for(var i= 0, l = oldArr.length; i&lt; l; i++)&#123; var item = oldArr[i]; full_name = [item.first_name,item.last_name].join(&quot; &quot;); newArr[i] = full_name; &#125; return newArr;&#125; console.log(getNewArr());//输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;] 使用map后 123456789101112var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;]; function getNewArr()&#123; return oldArr.map(function(item,index)&#123; full_name = [item.first_name,item.last_name].join(&quot; &quot;); return full_name; &#125;); &#125; console.log(getNewArr()); //输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;] 百度IFE的js任务(二)的运用传送门任务描述:参考以下示例代码，页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上 实现思路：1、用filter()方法筛选出值大于60的城市赋值给一个新的数组。2、用sort()对这个新的数组进行由大到小的排序。3、用forEach()代替for循环并动态创建li标签并打印名次和城市及其空气质量值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;污染城市列表&lt;/h3&gt; &lt;ul id=&quot;aqi-list&quot;&gt;&lt;!-- &lt;li&gt;第一名：福州（样例），10&lt;/li&gt; &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; --&gt; &lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt;var aqiData = [ [&quot;北京&quot;, 90], [&quot;上海&quot;, 50], [&quot;福州&quot;, 10], [&quot;广州&quot;, 50], [&quot;成都&quot;, 90], [&quot;西安&quot;, 100]];(function () &#123; /* 在注释下方编写代码 遍历读取aqiData中各个城市的数据 将空气质量指数大于60的城市显示到aqi-list的列表中 */ var aqiul=document.getElementById(&apos;aqi-list&apos;); //获取数组 //用filter()方法筛选出空气质量指数大于60的数组 var filtered = aqiData.filter(function(element, index, array)&#123; return (element[1] &gt;= 60); &#125;) ; filtered.sort(function(a,b)&#123; //从大到小排序 return b[1]-a[1]; &#125;); // (function wirte()&#123; //输出 用for循环 // for(var i=0;i&lt;filtered.length;i++)&#123; // var li=document.createElement(&apos;li&apos;); // aqiul.append(li); // li.innerHTML=&quot;第&quot;+(i+1)+&quot;名：&quot;+filtered[i]; // &#125; // &#125;)();//用forEach方法代替for循环 filtered.forEach(function(element, index, array)&#123; var li=document.createElement(&apos;li&apos;); aqiul.append(li); li.innerHTML=&quot;第&quot;+(index+1)+&quot;名：&quot;+filtered[index]; &#125;);&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于自执行函数（立即执行函数）]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%88%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[什么是自执行函数？一下有三种写法 1.最前最后加括号1(function()&#123;alert(1);&#125;()); 这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如： 12var a=1 (function()&#123;alert(1);&#125;()); 2.function外面加括号 1(function()&#123;alert(1);&#125;)(); 这种做法比方法1少了一个代码整体性的好处. 3.function前面加运算符，常见的是!与void 。 12!function()&#123;alert(1);&#125;(); void function()&#123;alert(2);&#125;(); 显然，加上“!”或“+”等运算符，写起来是最简单的。加上“void ”要敲五下键盘，但是听说有一个好处是，比加”!”少一次逻辑运算。 首先声明一个匿名函数 function(){alert(‘我是匿名函数’)}。 然后在匿名函数后面接一对括号 ()，调用这个匿名函数。 自执行函数的作用创建一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」） 例子来看一个著名的面试题： 123456var liList = ul.getElementsByTagName(&apos;li&apos;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是6,而不是0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢? 因为 i 是贯穿整个作用域的，而不是给每个li 分配了一个i,如下： 那么怎么解决这个问题呢？ 用立即执行函数给每个li创造一个独立作用域即可（当然还有其他办法）： 12345678var liList = ul.getElementsByTagName(&apos;li&apos;)for(var i=0; i&lt;6; i++)&#123; !function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。 (整理自网络)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于this对象的一个易错点]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9%2F</url>
      <content type="text"><![CDATA[先给一个例子123456789101112var name = &quot;The Window&quot;var object = &#123; name : &quot;My Object&quot;, f1 : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.f1()()); 这个例子返回的字符串是 “The Window”，为啥不是”My Object”呢？ 原因是每个函数在被调用时， 其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变最时， 只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 也就是说要想让闭包【return function(){}】访问到外部函数【f1 :function(){}】里的this（或者arguments）变量，就要先将其赋值给到一个闭包能够访问到的变量里，如var that = this，这样就可以了。 修改后的例子如下12345678910111213var name = &quot;The Window&quot;var object = &#123; name : &quot;My Object&quot;, f1 : function()&#123; var that = this; //添加这行 return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.f1()()); 返回”My Object” 另外一个例子1234567var name = &quot;The Window•;var object = &#123; name : &quot;My Object&quot;; getName: function() &#123; return this.name; &#125; &#125;; 上一个例子中的return function(){ return this.name；}被换掉了，不再是闭包 123object.getName(); //&apos;My Object&apos;(object.getName)(); //&apos;My Object&quot;(object.getName = object.getNamel (); //&quot;The Window•, 在非严格模式下 第一行代码跟平常一样词用了object.getName (), 返回的是飞y Object”, 因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后， 就好􀉀只是在引用一个函数， 但this的值得到了维持， 因为objec七.getName 和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再诮用赋值后的结果。因为这个赋值表达式的值是函数本身， 所以this的值不能得到维持， 结果就返回了崎The Window飞]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(二)]]></title>
      <url>%2F2017%2F04%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[继承概念OO语言中支持两种继承方式：实现继承，接口继承 实现继承：继承实际的方法 接口继承：继承函数签名 由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的原型链 原型链的问题（缺点） 1、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 2、在创建子类型的实例时，不能向超类型的构造函数中传递参数 默认的原型 所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。 如何确定原型和实例之间的关系 1、通过instanceof:测试实例与原型链中出现过的构造函数，结果会返回true 12345678910 alert(instance instanceof Object) //true alert(instance instanceof SuperType) //true alert(instance instanceof Subtype) //true ``` * 2、isPropertyOf()方法：只要是原型链中出现过的原型，都会返回true``` alert(Object.prtotype.isPropertyOf(instance)) //true alert(SuperType.prtotype.isPropertyOf(instance)) //true alert(Subtype.prtotype.isPropertyOf(instance)) //true 定义方法时要注意的几个问题 场景：子类型优势需要覆盖超类型中的某个方法，或者需要添加类型中不存在的某个方法 2、不能通过对象字面量方法添加新方法（因为会重写原型链） 1、给子类型添加方法的代码一定要放在替换原型的语句之后（否则会因为重新定义了原型而导致添加代码无效） 基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法例子：12345678910111213function SuperType()&#123; this.SuperProperty = true; &#125;; SuperType.prototype.getSuperProperty = function()&#123;return this.SuperProperty&#125;; function SubType()&#123; this.SubProperty = false; &#125;; SubType.prototype = new SuperType(); SubType.prototype.getSubProperty = function()&#123;return this.getSubProperty&#125;; var instance = new SubType(); alert(instance.getSuperProperty()) //true 借用构造函数缺点 1、方法都在构造函数中定义，函数无法复用，每个方法都是function的一个新实例 2、在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 传递参数 优点：借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数 123456789101112131415161718192021 function SuperType (name) &#123;function this.name= name; &#125; function SubType () &#123; //继承了Super&apos;l&apos;ype, 同时还传递了参数 superType.call(this, &quot;Nicholas&quot;); //实例属性 this.age= 29;&#125; var instance= new SubType(); alert(instance.name) ; //“Nicholas” alert(instance.age); //29 ``` #### 基本思想：在子类型构造函数中调用超类型构造函数 ``` function SuperType()&#123; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; function SubType()&#123; SuperType.call(this); &#125;; 组合继承概念 1、将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，又叫伪经典继承 2、基本思想：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承 3.是JavaScript中最常用的继承模式 优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式function SuperType(name){12345678910111213141516171819202122232425262728293031323334 this.name = name; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name)&#123; SuperType.call(this,name); this.age = age; &#125;; SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; ``` ### 原型式继承 #### Object.creat() * 参数一 * 用作新对象原型的对象 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person); ``` * 参数二 * 为新对象定义额外属性的对象（以这种方式指定的任何属性都会覆盖原型对象上的同名属性），注意格式 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person,&#123; name:&#123; value:&quot;Greg&quot; &#125; &#125;); ECMAScipt5通过新增的Object.create()规范化了原型式继承 核心12345function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; 例子123var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =object(person); //person成为了anotherPerson的原型 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。缺点：不能实现函数复用12345function creatAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123;alert(&quot;Hi&quot;)&#125;; return clone; &#125; 在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题 组合继承例子： 1234567891011121314function SuperType(name)&#123; //超类型构造函数 this.name=name; this.color=&#123;&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; SuperType.prototype.sayName=function()&#123; alert(this.name); function SubType(name,age)&#123; SuperType.call(this,name) //第二次调用 this.age = age; &#125; SubType.prototype = new SuperType(); //第一次调用 SubType.prototype.construtor =SuperType; SubType.protptype.sayAge =function()&#123; alert(this.age) 这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变123456 function inheritPrototype(subType,superType)&#123; //prototype成为superType的一个副本，而不用调用构造函数 var prototype = SuperType.prototype; prototype.constructor = SubType; SubType.prototype = prototype; &#125;; 例子12345678910111213141516function SuperType(name)&#123; this.name = name; &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(Subtype,SuperType); SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; function inheritPrototype(SubType，SuperType)&#123; var prototype = object(SuperType.prototype);//创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype ;//指定对象 &#125; 在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor屈性，从而弥补因重写原型而失去的默认的constructor属性。最后一步， 将新创建的对象（即副本）赋值给子类型的原型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[添加畅言评论]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[多说评论听说要关闭了，大家都在找评论系统替换。我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。 步骤教程写在简书上了，就不搬过来啦 简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[justjavac的知乎live听后总结]]></title>
      <url>%2F2017%2F04%2F23%2Fjustjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[get点： 1.跟别人互相review代码。2.系统学习js。多写算法相关的，少写特效。如写一个计算器。3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。 5.面试官会根据你写在简历里的东西提问。6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。7.扎实基础再去学框架8.移动端不用jQuery9.与其做很多项目，不如做精一个两项目。10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。11.对于学习，首选是看书，系统的全面的学。推荐的书：《黑客与画家》《javascript高级程序设计》《javascript精粹》《你不知道的javascript》推荐的网站：MDN等等。。。。。很多 讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔试整理(1)]]></title>
      <url>%2F2017%2F04%2F18%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1%2F</url>
      <content type="text"><![CDATA[1.CSS的某些样式是具有继承性的什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 2.对象的深拷贝与浅拷贝的区别 浅拷贝：仅仅复制对象的引用，而不是对象本身；深拷贝：把复制的对象所引用的全部对象都复制一遍。 浅拷贝例子： ================ 浅拷贝 ================ */1234567891011121314151617181920212223242526272829303132333435function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for ( var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj;&#125;客户端调用/* ================ 客户端调用 ================ */var obj = &#123; a: &quot;hello&quot;, b: &#123; a: &quot;world&quot;, b: 21 &#125;, c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;], d: function() &#123; alert(&quot;hello world&quot;); &#125;&#125;var cloneObj = simpleClone(obj); // 对象拷贝 console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 修改拷贝后的对象cloneObj.b.a = &quot;changed&quot;;cloneObj.c = [1, 2, 3];cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;; console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了 console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改 深拷贝的实现也有很多种方法，这里就介绍Object.create()方法 ================ 深拷贝 ================ */12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === &apos;object&apos;) &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(-)]]></title>
      <url>%2F2017%2F04%2F18%2Fjs%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[理解对象定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数属性类型 数据属性 [[Configurabke]]:能否通过delete删除属性从而重新定义属性 访问器属性 创建对象可以通过“构造函数”或者“对象字面量”方法创建函数 缺点：通过一个接口创建很多对象，会产生大量的重复代码 工厂模式 12345678 function creatPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; return o &#125; var person1 = creatPerson(“hxvin”,21,”F-E”); 用函数来封装以特定接口创建对象的细节 缺点：没有解决对象识别的问题 构造函数模式1234567function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function sayName()&#123;alert(this.name);&#125;; &#125;; var person1=new Person(“hxvin”,21,&quot;Front-end-Engineer&quot;); 和工厂模式的区别： 没有显式的创建对象 直接将属性和方法赋给了this 没有return语句 用这种方式调用构造函数会经历一下四个步骤 执行构造函数中的代码（为这个新对象添加属性） 创建一个新对象 将构造函数的作用域赋给新对象 返回新对象 缺点：每个方法都要在每个实例上创建一遍 上例中sayName方法相当于 this.sayName=new Funciton(“alert(name,age,job)”) 解决方法 12345678 function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName &#125;; function sayName()&#123;alert(this.name);&#125;; //将sayName添加到全局变量中，这样显然有很多不足 原型模式 原型模式 概念 每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以 由特定类型的所有实例共享的属性和方法 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法 创建原型: 12345 function Person()&#123;&#125;; Person.prototype.name=“hxvin”； Person.prototype.sayname=function()&#123; alert(this.name); &#125;； var person1=new Person(); person1.dayName(); //“hxvin” 理解原型 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针 搜索流程 当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性 每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找 hasOwnProperty() 用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true alert(person1 hasOwnProperty(“name”)); //返回true或false [[prototype]] 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象 利用[[prototype]] ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值 支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome 但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系 alert(Person.protoype isPrototypeOf(person1)); //true 没有标准的方式访问[[prototype]] 更简单的原型语法 123456789101112 //可以重新设置constructor function Perspn()&#123;&#125;; Person.prototype=&#123; constructor=Person, name=&quot;Nick&quot; &#125;; function Person()&#123;&#125;; Person.prototype=&#123; name=&quot;Nick&quot;, sayName=function()&#123;alert(this.name)&#125; &#125; 注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数 原型的动态性 注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针） 我们对原型对象所做的任何修改都能够立即从实例上反映出来 原型对象的问题（缺点） 1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值 2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来 组合使用构造函数模式和原型模式 123456789 function Person(name,age,job)&#123; this.name=name, this.age=age, this.job=job &#125;; Person.prototype=&#123; constructor=Person, sayName=function()&#123;alert(this.name)&#125; &#125; Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组 优点 每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存 创建自定义类型最常见的方式 支持向构造函数传递参数 动态原型模式123456789 function Person(name,age,job)&#123; //属性 this.name=name; this.age=age; this.job=job; //方法 if(typeof sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123;alert(this.name)&#125; &#125; &#125; //方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。 这里对原型所做的修改，能够立即在所有实例中得到反映。 把所有信息封装在构造函数中，并通过if语句初始化原型 寄生构造函数模式123456789 function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123;alert(o.name)&#125;; return o &#125;; var person1 = new Person(); 应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数 特点 返回的对象和构造函数没有关系 不能依赖instanceof操作符来确定对象类型 稳妥构造函数模式 所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。 function Person(name,age,job){ var o = new Object(); o.sayName = function(){alert(name)} } var friend = Person (“hxvin”,”21”,”f-e”); friend.sayName(}; //“hxvin” 这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。 这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。 应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用 特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数]]></content>
    </entry>

    
  
  
</search>
