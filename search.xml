<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[vue2的todolist入门小项目的详细解析]]></title>
      <url>%2F2017%2F05%2F09%2Fvue2%E7%9A%84todolist%E5%85%A5%E9%97%A8%E5%B0%8F%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[看完vue2的官方文档后，找个入门项目巩固下知识点，简单的todolsit是个不错的选择。项目用到了vue.js vue.cli webpack ES6 node环境，完成项目后会对这些技术栈有了些了解。 准备开发环境 $ npm install -g vue-cli $ vue init 如 vue innit webpack todolist $ cd todolist $ npm install $ npm run dev 安装谷歌插件vue.js devtools 下载vue.js的webpack模板 下载 todomvc的模板（也可以直接$ git clone https://github.com/tastejs/todomvc-app-template.git 来下载） 把todomvc的index.html拖到todolist文件夹去覆盖里面的index.html 打开todomvc的json文件，会看到 “todomvc-app-css”: “^2.0.0”,就是要你 npm install todomvc-app-css -S 从而下载该css 删点todolsit index.html的默认css，js引用，src文件夹下的main.js引入模板css（import‘todomvc-app-css/index.css’） 引入vue（import Vue form ‘vue’） main.js的代码 //后面的为注释讲解， ~表示串联index.html的对应内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import &apos;todomvc-app-css/index.css&apos;import Vue from &apos;vue&apos;//用过滤器筛选出三种状态var filters = &#123; all(todos) &#123; return todos &#125;, active(todos) &#123; return todos.filter((todo) =&gt; &#123; return !todo.completed &#125;) &#125;, completed(todos) &#123; return todos.filter((todo) =&gt; &#123; return todo.completed &#125;) &#125;,&#125;let app = new Vue(&#123; el: &apos;.todoapp&apos;, // ~ &lt;section class=&quot;todoapp&quot;&gt; data: &#123; msg: &apos;hello world&apos;, title: &apos;待做清单&apos;, // 渲染标题 ~ &#123;&#123;title&#125;&#125; newTodo: &apos;&apos;, todos: [&#123; // ~ v-show=&quot;todos.length&quot; ； ~ &#123;&#123;todos.length&gt;1?&apos;items&apos;:&apos;item&apos;&#125;&#125; content: &apos;下午：读完“追风筝的人”&apos;, // 渲染 li ~ v-for=&quot;(todo,index) in filteredTodos&quot; completed: false &#125;, &#123; content: &apos;晚上：写读书笔记&apos;, completed: false &#125;], editedTodo: &apos;&apos;, // 空的编辑对象 hashName: &apos;all&apos; &#125;, computed: &#123; remain() &#123; return filters.active(this.todos).length //未完成事项的数量 ~ &#123;&#123;remain&#125;&#125; &#125;, isAll: &#123; // ~ v-model=&quot;isAll&quot; get() &#123; return this.remain === 0 &#125;, set(value) &#123; this.todos.forEach((todo) =&gt; &#123; todo.completed = value &#125;) &#125; &#125;, filteredTodos() &#123; //用hashName过滤出当前页面的todos ~ v-for=&quot;(todo,index) in filteredTodos&quot; return filters[this.hashName](this.todos) &#125; &#125;, methods: &#123; addTodo(e) &#123; //输入值为空时，不添加（trim去除前后空格） ~ v-model.trim=&quot;newTodo&quot; if (!this.newTodo) &#123; return &#125; this.todos.push(&#123; content: this.newTodo, completed: false //结合v-model 根据completed状态绑定样式 ~:class=&quot;&#123;completed:todo.completed； ~ v-model=&quot;todo.completed&quot; &#125;) this.newTodo = &apos;&apos; &#125;, removeTodo(index) &#123; //绑定x样式，点击删除该todo ~ @click=&quot;removeTodo(index)&quot; this.todos.splice(index, 1) &#125;, editTodo(todo) &#123; //编辑 ~ @dblclick=&quot;editTodo(todo)&quot; this.editCache = todo.content //储存编辑前的内容 this.editedTodo = todo // 点击编辑里面的内容而不是只是空文本框~ editing:todo==editedTodo&#125;&quot; &#125;, doneEdit(todo, index) &#123; //失去焦点后 ~ @blur=&quot;doneEdit(todo)&quot;；@keyup.enter=&quot;doneEdit(todo)&quot; this.editedTodo = null //不存在编辑了或者说编辑已完成 if (!todo.content) &#123; //如果编辑后没有内容了，删除该todo this.removeTodo(index) &#125; &#125;, cancelEdit(todo) &#123; //按esc键取消此次编辑操作 ~ @keyup.esc=&quot;cancelEdit(todo)&quot;&gt; this.editedTodo = null todo.content = this.editCache //当esc取消编辑时，还原编辑前的内容 &#125;, clear() &#123; //点击清除已完成的功能 ~ @click=&quot;clear&quot; this.todos = filters.active(this.todos) //获取并渲染未完成的事项 ~ &#125; &#125;, directives: &#123; //自定义属性 ~ v-focus=&quot;todo == editedTodo&quot; focus(el, value) &#123; //文本框双击获取焦点 if (value) &#123; el.focus() &#125; &#125; &#125;&#125;)//hash（url地址中#以及之后的字符）function hashChange() &#123; // ~ :class=&quot;&#123;selected:hashName==&apos;all&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;active&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;completed&apos;&#125;&quot; let hashName = location.hash.replace(/#\/?/, &apos;&apos;) //正则表达式去除#/？，获取如all，active，completed if (filters[hashName]) &#123; //如果过滤状态的hashName存在 app.hashName = hashName //给整个app变量里的hashName赋上那个值 &#125; else &#123; location.hash = &apos;&apos; //取消 app.hashName = &apos;all&apos; //否则就赋值‘all’，回到全部事项的页面 &#125;&#125;window.addEventListener(&apos;hashchange&apos;, hashChange) //全局监听hash]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>%2F2017%2F04%2F29%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[轻松学习JS快速排序(QuickSort)]]></title>
      <url>%2F2017%2F04%2F29%2F%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0JS%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort%2F</url>
      <content type="text"><![CDATA[需了解的基础知识 1.递归函数：编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。 一个典型阶乘递归函数： 1234567function fact(num)&#123; if (num&lt;=1)&#123; return 1; &#125;else&#123; return num*fact(num-1); &#125; &#125; 该函数的弊端： 123var another=factorical;factorical=null;console.log(another(2))//会报错说 factorical not a function 解决方法: 用arguments.callee去代替函数名，就可以确保函数不管怎么调用都不会出错。 1234567891011function factorical(num)&#123; if(num&lt;=1)&#123; return 1; &#125; else&#123; return num*arguments.callee(num-1); &#125;&#125;var another=factorical;factorical=null;console.log(another(2))//2 (来自js高程) 2.JavaScript中的splice方法用法详解 3.JavaScript concat()方法 3.Javascript之Math对象详解 步骤以下内容整理自阮一峰老师的快速排序（Quicksort）的Javascript实现 首先，定义一个quickSort函数，它的参数是一个数组。 var quickSort = function(arr) { 然后，检查数组的元素个数，如果小于等于1，就返回。 if (arr.length &lt;= 1) { return arr; } 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。splice返回的是数组,用[0]返回值 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。 for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } 最后，使用递归不断重复这个过程，就可以得到排序后的数组。 return quickSort(left).concat([pivot], quickSort(right));}; 使用的时候，直接调用quickSort()就行了。 最终的快排函数123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 实例运用12var array = [7,4,1,9,6,3,2,5,8] ;quickSort(array); //输出1，2，3，4，5，6，7，8，9]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发中js数组的常用方法]]></title>
      <url>%2F2017%2F04%2F27%2F%E5%BC%80%E5%8F%91%E4%B8%ADjs%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在ES5中，一共有9个Array方法： Array.prototype.indexOf;Array.prototype.lastIndexOf;Array.prototype.every;Array.prototype.some;Array.prototype.forEach;Array.prototype.map;Array.prototype.filter;Array.prototype.reduce;Array.prototype.reduceRight; 5种比较常用=&gt;index(),filter(),forEach(),map(),reduce(). ps:reduce()还没搞懂，就先不整理了。文末有个实例了解实际运用。 介绍1) indexOfindexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。不使用indexOf时： 123456789var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],found = false; for(var i= 0, l = arr.length; i&lt; l; i++)&#123;if(arr[i] === &apos;a&apos;)&#123;found = true;&#125;&#125;console.log(&quot;found:&quot;,found);//输出found: true indexOf使用后 123var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; console.log(&quot;found:&quot;, arr.indexOf(&quot;a&quot;) != -1);//输出found: true 2) filter该filter()方法创建一个新的匹配过滤条件的数组。 不用 filter() 时 12345678910111213141516var arr = [ [&quot;a&quot;, 2], [&quot;b&quot;, 5], [&quot;c&quot;, 3], [&quot;b&quot;, 16],]; var newArr = []; for(var i= 0, l = arr.length; i&lt; l; i++)&#123; if(arr[i][0] == &quot;b&quot; )&#123;newArr.push(arr[i]);&#125;&#125; alert(newArr);//输出b,5,b,16 用了 filter(): 1234567891011var arr = [ [&quot;a&quot;, 2], [&quot;b&quot;, 5], [&quot;c&quot;, 3], [&quot;b&quot;, 16],]; var newArr = arr.filter(function(element, index, array)&#123; return element[0] == &quot;b&quot; ;&#125;); alert(newArr); //输出b,5,b,16 3) forEach()forEach为每个元素执行对应的方法,用来替换for循环 不用 forEach() 时 1234var arr = [1,2,3,4,5,6,7,8];for(var i= 0, l = arr.length; i&lt; l; i++)&#123;console.log(arr[i]); //输出 1 2 3 4 5 6 7 8 &#125; 用了forEach() 1234var arr = [1,2,3,4,5,6,7,8];arr.forEach(function(element, index, array)&#123;console.log(element);//输出 1 2 3 4 5 6 7 8 &#125;); 4) map()map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组，不使用mapmap()是处理服务器返回数据时是一个非常实用的函数。 不用 map() 时 12345678910111213141516var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;]; function getNewArr()&#123; var newArr = []; for(var i= 0, l = oldArr.length; i&lt; l; i++)&#123; var item = oldArr[i]; full_name = [item.first_name,item.last_name].join(&quot; &quot;); newArr[i] = full_name; &#125; return newArr;&#125; console.log(getNewArr());//输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;] 使用map后 123456789101112var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;]; function getNewArr()&#123; return oldArr.map(function(item,index)&#123; full_name = [item.first_name,item.last_name].join(&quot; &quot;); return full_name; &#125;); &#125; console.log(getNewArr()); //输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;] 百度IFE的js任务(二)的运用传送门任务描述:参考以下示例代码，页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上 实现思路：1、用filter()方法筛选出值大于60的城市赋值给一个新的数组。2、用sort()对这个新的数组进行由大到小的排序。3、用forEach()代替for循环并动态创建li标签并打印名次和城市及其空气质量值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;污染城市列表&lt;/h3&gt; &lt;ul id=&quot;aqi-list&quot;&gt;&lt;!-- &lt;li&gt;第一名：福州（样例），10&lt;/li&gt; &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; --&gt; &lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt;var aqiData = [ [&quot;北京&quot;, 90], [&quot;上海&quot;, 50], [&quot;福州&quot;, 10], [&quot;广州&quot;, 50], [&quot;成都&quot;, 90], [&quot;西安&quot;, 100]];(function () &#123; /* 在注释下方编写代码 遍历读取aqiData中各个城市的数据 将空气质量指数大于60的城市显示到aqi-list的列表中 */ var aqiul=document.getElementById(&apos;aqi-list&apos;); //获取数组 //用filter()方法筛选出空气质量指数大于60的数组 var filtered = aqiData.filter(function(element, index, array)&#123; return (element[1] &gt;= 60); &#125;) ; filtered.sort(function(a,b)&#123; //从大到小排序 return b[1]-a[1]; &#125;); // (function wirte()&#123; //输出 用for循环 // for(var i=0;i&lt;filtered.length;i++)&#123; // var li=document.createElement(&apos;li&apos;); // aqiul.append(li); // li.innerHTML=&quot;第&quot;+(i+1)+&quot;名：&quot;+filtered[i]; // &#125; // &#125;)();//用forEach方法代替for循环 filtered.forEach(function(element, index, array)&#123; var li=document.createElement(&apos;li&apos;); aqiul.append(li); li.innerHTML=&quot;第&quot;+(index+1)+&quot;名：&quot;+filtered[index]; &#125;);&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于自执行函数（立即执行函数）]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%88%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[什么是自执行函数？一下有三种写法 1.最前最后加括号1(function()&#123;alert(1);&#125;()); 这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如： 12var a=1 (function()&#123;alert(1);&#125;()); 2.function外面加括号 1(function()&#123;alert(1);&#125;)(); 这种做法比方法1少了一个代码整体性的好处. 3.function前面加运算符，常见的是!与void 。 12!function()&#123;alert(1);&#125;(); void function()&#123;alert(2);&#125;(); 显然，加上“!”或“+”等运算符，写起来是最简单的。加上“void ”要敲五下键盘，但是听说有一个好处是，比加”!”少一次逻辑运算。 首先声明一个匿名函数 function(){alert(‘我是匿名函数’)}。 然后在匿名函数后面接一对括号 ()，调用这个匿名函数。 自执行函数的作用创建一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」） 例子来看一个著名的面试题： 123456var liList = ul.getElementsByTagName(&apos;li&apos;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是6,而不是0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢? 因为 i 是贯穿整个作用域的，而不是给每个li 分配了一个i,如下： 那么怎么解决这个问题呢？ 用立即执行函数给每个li创造一个独立作用域即可（当然还有其他办法）： 12345678var liList = ul.getElementsByTagName(&apos;li&apos;)for(var i=0; i&lt;6; i++)&#123; !function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。 (整理自网络)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于this对象的一个易错点]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9%2F</url>
      <content type="text"><![CDATA[先给一个例子123456789101112var name = &quot;The Window&quot;var object = &#123; name : &quot;My Object&quot;, f1 : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.f1()()); 这个例子返回的字符串是 “The Window”，为啥不是”My Object”呢？ 原因是每个函数在被调用时， 其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变最时， 只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 也就是说要想让闭包【return function(){}】访问到外部函数【f1 :function(){}】里的this（或者arguments）变量，就要先将其赋值给到一个闭包能够访问到的变量里，如var that = this，这样就可以了。 修改后的例子如下12345678910111213var name = &quot;The Window&quot;var object = &#123; name : &quot;My Object&quot;, f1 : function()&#123; var that = this; //添加这行 return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.f1()()); 返回”My Object” 另外一个例子1234567var name = &quot;The Window•;var object = &#123; name : &quot;My Object&quot;; getName: function() &#123; return this.name; &#125; &#125;; 上一个例子中的return function(){ return this.name；}被换掉了，不再是闭包 123object.getName(); //&apos;My Object&apos;(object.getName)(); //&apos;My Object&quot;(object.getName = object.getNamel (); //&quot;The Window•, 在非严格模式下 第一行代码跟平常一样词用了object.getName (), 返回的是飞y Object”, 因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后， 就好􀉀只是在引用一个函数， 但this的值得到了维持， 因为objec七.getName 和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再诮用赋值后的结果。因为这个赋值表达式的值是函数本身， 所以this的值不能得到维持， 结果就返回了崎The Window飞]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(二)]]></title>
      <url>%2F2017%2F04%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[继承概念OO语言中支持两种继承方式：实现继承，接口继承 实现继承：继承实际的方法 接口继承：继承函数签名 由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的原型链 原型链的问题（缺点） 1、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 2、在创建子类型的实例时，不能向超类型的构造函数中传递参数 默认的原型 所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。 如何确定原型和实例之间的关系 1、通过instanceof:测试实例与原型链中出现过的构造函数，结果会返回true 12345678910 alert(instance instanceof Object) //true alert(instance instanceof SuperType) //true alert(instance instanceof Subtype) //true ``` * 2、isPropertyOf()方法：只要是原型链中出现过的原型，都会返回true``` alert(Object.prtotype.isPropertyOf(instance)) //true alert(SuperType.prtotype.isPropertyOf(instance)) //true alert(Subtype.prtotype.isPropertyOf(instance)) //true 定义方法时要注意的几个问题 场景：子类型优势需要覆盖超类型中的某个方法，或者需要添加类型中不存在的某个方法 2、不能通过对象字面量方法添加新方法（因为会重写原型链） 1、给子类型添加方法的代码一定要放在替换原型的语句之后（否则会因为重新定义了原型而导致添加代码无效） 基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法例子：12345678910111213function SuperType()&#123; this.SuperProperty = true; &#125;; SuperType.prototype.getSuperProperty = function()&#123;return this.SuperProperty&#125;; function SubType()&#123; this.SubProperty = false; &#125;; SubType.prototype = new SuperType(); SubType.prototype.getSubProperty = function()&#123;return this.getSubProperty&#125;; var instance = new SubType(); alert(instance.getSuperProperty()) //true 借用构造函数缺点 1、方法都在构造函数中定义，函数无法复用，每个方法都是function的一个新实例 2、在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 传递参数 优点：借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数 123456789101112131415161718192021 function SuperType (name) &#123;function this.name= name; &#125; function SubType () &#123; //继承了Super&apos;l&apos;ype, 同时还传递了参数 superType.call(this, &quot;Nicholas&quot;); //实例属性 this.age= 29;&#125; var instance= new SubType(); alert(instance.name) ; //“Nicholas” alert(instance.age); //29 ``` #### 基本思想：在子类型构造函数中调用超类型构造函数 ``` function SuperType()&#123; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; function SubType()&#123; SuperType.call(this); &#125;; 组合继承概念 1、将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，又叫伪经典继承 2、基本思想：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承 3.是JavaScript中最常用的继承模式 优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式function SuperType(name){12345678910111213141516171819202122232425262728293031323334 this.name = name; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name)&#123; SuperType.call(this,name); this.age = age; &#125;; SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; ``` ### 原型式继承 #### Object.creat() * 参数一 * 用作新对象原型的对象 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person); ``` * 参数二 * 为新对象定义额外属性的对象（以这种方式指定的任何属性都会覆盖原型对象上的同名属性），注意格式 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person,&#123; name:&#123; value:&quot;Greg&quot; &#125; &#125;); ECMAScipt5通过新增的Object.create()规范化了原型式继承 核心12345function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; 例子123var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =object(person); //person成为了anotherPerson的原型 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。缺点：不能实现函数复用12345function creatAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123;alert(&quot;Hi&quot;)&#125;; return clone; &#125; 在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题 组合继承例子： 1234567891011121314function SuperType(name)&#123; //超类型构造函数 this.name=name; this.color=&#123;&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; SuperType.prototype.sayName=function()&#123; alert(this.name); function SubType(name,age)&#123; SuperType.call(this,name) //第二次调用 this.age = age; &#125; SubType.prototype = new SuperType(); //第一次调用 SubType.prototype.construtor =SuperType; SubType.protptype.sayAge =function()&#123; alert(this.age) 这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变123456 function inheritPrototype(subType,superType)&#123; //prototype成为superType的一个副本，而不用调用构造函数 var prototype = SuperType.prototype; prototype.constructor = SubType; SubType.prototype = prototype; &#125;; 例子12345678910111213141516function SuperType(name)&#123; this.name = name; &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(Subtype,SuperType); SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; function inheritPrototype(SubType，SuperType)&#123; var prototype = object(SuperType.prototype);//创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype ;//指定对象 &#125; 在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor屈性，从而弥补因重写原型而失去的默认的constructor属性。最后一步， 将新创建的对象（即副本）赋值给子类型的原型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[添加畅言评论]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[多说评论听说要关闭了，大家都在找评论系统替换。我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。 步骤教程写在简书上了，就不搬过来啦 简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[justjavac的知乎live听后总结]]></title>
      <url>%2F2017%2F04%2F23%2Fjustjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[get点： 1.跟别人互相review代码。2.系统学习js。多写算法相关的，少写特效。如写一个计算器。3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。 5.面试官会根据你写在简历里的东西提问。6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。7.扎实基础再去学框架8.移动端不用jQuery9.与其做很多项目，不如做精一个两项目。10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。11.对于学习，首选是看书，系统的全面的学。推荐的书：《黑客与画家》《javascript高级程序设计》《javascript精粹》《你不知道的javascript》推荐的网站：MDN等等。。。。。很多 讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一次笔试，整理(1)]]></title>
      <url>%2F2017%2F04%2F18%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1%2F</url>
      <content type="text"><![CDATA[之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了. 特别想提的一点是在过程中感觉到美图的HR和技术总监为人很 nice，~(≧▽≦)/~赞。** 这几天都在考期中考，所以笔试完也没马上做总结就去准备接下去接连一天一科的期中考了。 笔试有要求题目不能外泄，以下只是自己依稀记得的不大会做，不会做的知识点，仅供补缺补漏使用。 1.CSS的某些样式是具有继承性的什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 2.对象的深拷贝与浅拷贝的区别 浅拷贝：仅仅复制对象的引用，而不是对象本身；深拷贝：把复制的对象所引用的全部对象都复制一遍。 浅拷贝例子： ================ 浅拷贝 ================ */1234567891011121314151617181920212223242526272829303132333435function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for ( var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj;&#125;客户端调用/* ================ 客户端调用 ================ */var obj = &#123; a: &quot;hello&quot;, b: &#123; a: &quot;world&quot;, b: 21 &#125;, c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;], d: function() &#123; alert(&quot;hello world&quot;); &#125;&#125;var cloneObj = simpleClone(obj); // 对象拷贝 console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 修改拷贝后的对象cloneObj.b.a = &quot;changed&quot;;cloneObj.c = [1, 2, 3];cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;; console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了 console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改 深拷贝的实现也有很多种方法，这里就介绍Object.create()方法 ================ 深拷贝 ================ */12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === &apos;object&apos;) &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(-)]]></title>
      <url>%2F2017%2F04%2F18%2Fjs%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[理解对象定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数属性类型 数据属性 [[Configurabke]]:能否通过delete删除属性从而重新定义属性 访问器属性 创建对象可以通过“构造函数”或者“对象字面量”方法创建函数 缺点：通过一个接口创建很多对象，会产生大量的重复代码 工厂模式 12345678 function creatPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; return o &#125; var person1 = creatPerson(“hxvin”,21,”F-E”); 用函数来封装以特定接口创建对象的细节 缺点：没有解决对象识别的问题 构造函数模式1234567function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function sayName()&#123;alert(this.name);&#125;; &#125;; var person1=new Person(“hxvin”,21,&quot;Front-end-Engineer&quot;); 和工厂模式的区别： 没有显式的创建对象 直接将属性和方法赋给了this 没有return语句 用这种方式调用构造函数会经历一下四个步骤 执行构造函数中的代码（为这个新对象添加属性） 创建一个新对象 将构造函数的作用域赋给新对象 返回新对象 缺点：每个方法都要在每个实例上创建一遍 上例中sayName方法相当于 this.sayName=new Funciton(“alert(name,age,job)”) 解决方法 12345678 function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName &#125;; function sayName()&#123;alert(this.name);&#125;; //将sayName添加到全局变量中，这样显然有很多不足 原型模式 原型模式 概念 每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以 由特定类型的所有实例共享的属性和方法 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法 创建原型: 12345 function Person()&#123;&#125;; Person.prototype.name=“hxvin”； Person.prototype.sayname=function()&#123; alert(this.name); &#125;； var person1=new Person(); person1.dayName(); //“hxvin” 理解原型 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针 搜索流程 当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性 每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找 hasOwnProperty() 用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true alert(person1 hasOwnProperty(“name”)); //返回true或false [[prototype]] 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象 利用[[prototype]] ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值 支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome 但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系 alert(Person.protoype isPrototypeOf(person1)); //true 没有标准的方式访问[[prototype]] 更简单的原型语法 123456789101112 //可以重新设置constructor function Perspn()&#123;&#125;; Person.prototype=&#123; constructor=Person, name=&quot;Nick&quot; &#125;; function Person()&#123;&#125;; Person.prototype=&#123; name=&quot;Nick&quot;, sayName=function()&#123;alert(this.name)&#125; &#125; 注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数 原型的动态性 注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针） 我们对原型对象所做的任何修改都能够立即从实例上反映出来 原型对象的问题（缺点） 1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值 2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来 组合使用构造函数模式和原型模式 123456789 function Person(name,age,job)&#123; this.name=name, this.age=age, this.job=job &#125;; Person.prototype=&#123; constructor=Person, sayName=function()&#123;alert(this.name)&#125; &#125; Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组 优点 每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存 创建自定义类型最常见的方式 支持向构造函数传递参数 动态原型模式123456789 function Person(name,age,job)&#123; //属性 this.name=name; this.age=age; this.job=job; //方法 if(typeof sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123;alert(this.name)&#125; &#125; &#125; //方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。 这里对原型所做的修改，能够立即在所有实例中得到反映。 把所有信息封装在构造函数中，并通过if语句初始化原型 寄生构造函数模式123456789 function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123;alert(o.name)&#125;; return o &#125;; var person1 = new Person(); 应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数 特点 返回的对象和构造函数没有关系 不能依赖instanceof操作符来确定对象类型 稳妥构造函数模式 所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。 function Person(name,age,job){ var o = new Object(); o.sayName = function(){alert(name)} } var friend = Person (“hxvin”,”21”,”f-e”); friend.sayName(}; //“hxvin” 这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。 这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。 应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用 特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数]]></content>
    </entry>

    
  
  
</search>
