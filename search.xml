<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[添加畅言评论]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[####多说评论听说要关闭了，大家都在找评论系统替换。 ####我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。 ####而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。 步骤教程写在简书上了，就不搬过来啦 简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[justjavac的知乎live听后总结]]></title>
      <url>%2F2017%2F04%2F23%2Fjustjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[get点： 1.跟别人互相review代码。2.系统学习js。多写算法相关的，少写特效。如写一个计算器。3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。 5.面试官会根据你写在简历里的东西提问。6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。7.扎实基础再去学框架8.移动端不用jQuery9.与其做很多项目，不如做精一个两项目。10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。11.对于学习，首选是看书，系统的全面的学。推荐的书：《黑客与画家》《javascript高级程序设计》《javascript精粹》《你不知道的javascript》推荐的网站：MDN等等。。。。。很多 讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一次笔试，整理(1)]]></title>
      <url>%2F2017%2F04%2F18%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1%2F</url>
      <content type="text"><![CDATA[之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了.特别想提的一点是在过程中感觉到美图的HR和技术总监为人很 nice，~(≧▽≦)/~赞。 这几天都在考期中考，所以笔试完也没马上做总结就去准备接下去接连一天一科的期中考了。 笔试有要求题目不能外泄，以下只是自己依稀记得的不大会做，不会做的知识点，仅供补缺补漏使用。 1.CSS的某些样式是具有继承性的什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 2.对象的深拷贝与浅拷贝的区别 浅拷贝：仅仅复制对象的引用，而不是对象本身；深拷贝：把复制的对象所引用的全部对象都复制一遍。 浅拷贝例子： ================ 浅拷贝 ================ */1234567891011121314151617181920212223242526272829303132333435function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for ( var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj;&#125;客户端调用/* ================ 客户端调用 ================ */var obj = &#123; a: &quot;hello&quot;, b: &#123; a: &quot;world&quot;, b: 21 &#125;, c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;], d: function() &#123; alert(&quot;hello world&quot;); &#125;&#125;var cloneObj = simpleClone(obj); // 对象拷贝 console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 修改拷贝后的对象cloneObj.b.a = &quot;changed&quot;;cloneObj.c = [1, 2, 3];cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;; console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了 console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改 深拷贝的实现也有很多种方法，这里就介绍Object.create()方法 ================ 深拷贝 ================ */12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === &apos;object&apos;) &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(-)]]></title>
      <url>%2F2017%2F04%2F18%2Fjs%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[面向对象的程序设计理解对象定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数属性类型 数据属性 [[Configurabke]]:能否通过delete删除属性从而重新定义属性 访问器属性 创建对象可以通过“构造函数”或者“对象字面量”方法创建函数 缺点：通过一个接口创建很多对象，会产生大量的重复代码 工厂模式 function creatPerson(name,age,job){ var o=new Object(); o.name=name; o.age=age; o.job=job; return o } var person1 = creatPerson(“hxvin”,21,”F-E”); 用函数来封装以特定接口创建对象的细节 缺点：没有解决对象识别的问题 构造函数模式 function Person(name,age,job){ this.name=name; this.age=age; this.job=job; this.sayName=function sayName(){alert(this.name);}; }; var person1=new Person(“hxvin”,21,”Front-end-Engineer”); 和工厂模式的区别： 没有显式的创建对象 直接将属性和方法赋给了this 没有return语句 用这种方式调用构造函数会经历一下四个步骤 执行构造函数中的代码（为这个新对象添加属性） 创建一个新对象 将构造函数的作用域赋给新对象 返回新对象 缺点：每个方法都要在每个实例上创建一遍 上例中sayName方法相当于this.sayName=new Funciton(“alert(name,age,job)”) 解决方法 function Person(name,age,job){ this.name=name; this.age=age; this.job=job; this.sayName=sayName }; function sayName(){alert(this.name);}; //将sayName添加到全局变量中，这样显然有很多不足 原型模式 原型模式 概念 每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以 由特定类型的所有实例共享的属性和方法 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法 创建原型:function Person(){}; Person.prototype.name=“hxvin”；Person.prototype.sayname=function(){ alert(this.name); }； var person1=new Person(); person1.dayName(); //“hxvin” 理解原型 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针 搜索流程 当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性 每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找 hasOwnProperty() 用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true alert(person1 hasOwnProperty(“name”)); //返回true或false [[prototype]] 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象 利用[[prototype]] ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值 支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome 但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系 alert(Person.protoype isPrototypeOf(person1)); //true 没有标准的方式访问[[prototype]] 更简单的原型语法 //可以重新设置constructor function Perspn(){}; Person.prototype={ constructor=Person, name=&quot;Nick&quot; }; function Person(){}; Person.prototype={ name=&quot;Nick&quot;, sayName=function(){alert(this.name)} } 注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数 原型的动态性 注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针） 我们对原型对象所做的任何修改都能够立即从实例上反映出来 原型对象的问题（缺点） 1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值 2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来 组合使用构造函数模式和原型模式 function Person(name,age,job){ this.name=name, this.age=age, this.job=job }; Person.prototype={ constructor=Person, sayName=function(){alert(this.name)} } Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组 优点 每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存 创建自定义类型最常见的方式 支持向构造函数传递参数 动态原型模式 function Person(name,age,job){ //属性 this.name=name; this.age=age; this.job=job; //方法 if(typeof sayName != &quot;function&quot;){ Person.prototype.sayName = function(){alert(this.name)} } } //方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。 这里对原型所做的修改，能够立即在所有实例中得到反映。 把所有信息封装在构造函数中，并通过if语句初始化原型 寄生构造函数模式 function Person(name,age,job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){alert(o.name)}; return o }; var person1 = new Person(); 应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数 特点 返回的对象和构造函数没有关系 不能依赖instanceof操作符来确定对象类型 稳妥构造函数模式 所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。 function Person(name,age,job){ var o = new Object(); o.sayName = function(){alert(name)} } var friend = Person (“hxvin”,”21”,”f-e”); friend.sayName(}; //“hxvin” &gt;这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。 这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。 应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用 特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数]]></content>
    </entry>

    
  
  
</search>
