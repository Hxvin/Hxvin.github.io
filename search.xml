<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[“js各种遍历总结”]]></title>
      <url>%2F2017%2F11%2F19%2F%E2%80%9Cjs%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93%E2%80%9D%2F</url>
      <content type="text"><![CDATA[最近忙着写项目，是时候来一波总结了。因为项目中数据交互炒！鸡！多！，遍历很常用，本篇对js的遍历做一次总结 一 、普通for循环 (只能遍历数组和字符串) 遍历数组 1234var arr = [1,2,3,4,5];for(var i = 0 ; i &lt; arr.length; i++)&#123; console.log(i); //1 2 3 4 5 &#125; 不足：重复获取数组长度 优化 1234var arr = [1,2,3,4,5];for(var i = 0 ; len = arr.length ; i &lt; len; i++)&#123; console.log(i); //1 2 3 4 5 &#125; 使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。 这种方法基本上是所有循环遍历方法中性能最高的一种 遍历字符串 1234567891011121314var str = &quot;for循环遍历字符串&quot; ;for (var i = 0; i &lt; str.length; i++) &#123;console.log(str[i]+&apos;==&apos;+str.charAt(i)+&apos;==&apos;+str.charCodeAt(i));//f==f==102 o==o==111 r==r==114循==循==24490 环==环==29615 遍==遍==36941 历==历==21382 字==字==23383 符==符==31526 串==串==20018&#125; 遍历对象 不能使用 ###二、 for..in..循环 （可以遍历字符串、对象、数组） 这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中 它的效率是最低的 遍历数组 1234var arr = [2,3,4]for (var i in arr) &#123; console.log(arr[i]);//2 3 4 &#125; 遍历对象 123456var obj = &#123;name:&quot;xiaoming&quot;,age:&quot;18&quot;&#125;for (var prop in obj) &#123; console.log(obj[prop]); // xiaoming 18 &#125; 遍历字符串 1234567891011var str = &quot;循环遍历字符串&quot;;for(var i in str)&#123; console.log(i+&quot;~&quot;+str[i]);&#125;//0~循1~环2~遍3~历4~字5~符6~串 三、 forEach 循环(不能遍历字符串、对象) 遍历数组 1234var arr = [1,2,3,4,5];arr.forEach(function(e)&#123; console.log(e); //1 2 3 4 5 &#125;) 12345var arr = [3,4,5];arr.forEach(function(ele,index,arr)&#123; console.log(ele+&apos;~&apos;+index); //3 ~ 0 4~1 5~2 console.log(arr[index]); // 3 4 5 &#125;); 数组自带的foreach循环，使用频率较高，实际上性能比普通for循环弱 forEach遍历字符串 不能使用 forEach遍历对象 不能使用 四、 for..of..循环 (需要ES6支持,且不能遍历对象) 遍历数组 1234var str = [2,3,4,5];for (var ele of str) &#123; console.log(ele); // 2 3 4 5 &#125; 遍历对象 不能遍历，需要实现Symbol.interator接口 遍历字符串 1234var str = &quot;循环遍历字符串&quot;;for (var ele of str) &#123; console.log(ele);// 循 环 遍 历 字 符 串&#125; 这种方式是es6里面用到的，性能要好于forin，但仍然比不上普通for循环ps：个人感觉数组的用法和forEach挺相似，都是操作数组的元素 五、map 遍历数组 123456function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); map是操作每一个arr的元素，如上例子中对数组的每一个元素执行pow方法。最后的结果仍是数组。这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上foreach 推荐阅读js遍历方式总结JS几种数组遍历方式以及性能分析对比]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“一个人的前端之旅，写写感想~”]]></title>
      <url>%2F2017%2F11%2F19%2F%E2%80%9C%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B9%8B%E6%97%85%EF%BC%8C%E5%86%99%E5%86%99%E6%84%9F%E6%83%B3-%E2%80%9D%2F</url>
      <content type="text"><![CDATA[想想步入前端，成为一名码农已经快一年(大概还差两个多月吧)，自己从小 心水的技术梦也算有了着落。 这次参加了后半段秋招，7~10月一直忙着实习，十月中旬真正开始参加了校招，虽然对互联网校招来说，算蛮晚的，很多大厂的校招也结束了，哈哈哈，后知后觉。 想起面试中面试官喜欢问的一个问题，你一个非科班的为什么选择前端，我总是叽叽歪歪说了一堆，其实很简单，我想当一名程序员(慕名已久)，刚好遇见了前端，是前端让我打破非科班难以成为程序员的狭隘眼界~感谢 然后，我喜欢js，一门前后端，pc端，客户端，桌面端通吃的奇妙语言，虽然目前自己掌握的js依然很菜，但有一天，我相信自己会成为很好的jser的，希望这天早点到来，希望有一天我能用js写出在各种使用环境下跑的优质产品。 一直在探索适合自己的学习方式，后来项目驱动成为了我的学习自驱方式，不过这样倒是忽略了对js基础知识的巩固，校招中也吃了亏，后遇一名前辈指点，对自己学习模式完善了下，项目驱动为主干，在项目中遇到不会，不解的知识点和坑，及时去做总结，不单单是总结那个知识点，而应是由点及线到面，比如js遍历中的foreach 用法不是很熟悉，这时候就可以把整个js遍历的方法总结出来，把知识点串联成一条线，甚至一个面。 作为一名技术菜，虽然技术接触了不少，HTML(5),CSS(3),ES(6,7),VUE,REACT,NODE,KOA,EJS,GULP,SCSS,MYSQL,LINUX….但是 由于时间原因，有些只是是浅尝而止，想想这样不是很好，是走路都艰难的虚胖，所以呢，给接下去的自己做下规划~~ 具体的规划还是我完成了再写出来吧，不过要成为一名程序员，数据结构算法分析这些肯定跑不了的了，而且还有很多很nice的书等我去看~~先酱紫 加油 进击的菜鸡！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搁浅]]></title>
      <url>%2F2017%2F10%2F24%2F%E6%90%81%E6%B5%85%2F</url>
      <content type="text"><![CDATA[最近有点茫然，对于编程的学习，到底什么样的方法才是好的，才是适合我的。 实习三个月，我不断汲取新知识新技术，react，node，php，git。。。各种，又杂又乱，虽说刚开始是挺崩溃，比如node，php一周上手写项目代码，react两天上手写项目代码，以前习惯系统学习的我不得不做出适应，快速去学习。 这样的环境下，步伐迈得很快，但是都是学部分部分的，没有系统，所以感觉自己不敢说会这门技术。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单的方法掌握JS中slice,splice和split的使用方法]]></title>
      <url>%2F2017%2F10%2F15%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E6%8E%8C%E6%8F%A1JS%E4%B8%ADslice-splice%E5%92%8Csplit%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[首先，js的api的命名一般都有它的意义所在，通过英文就能大概理解是干啥用的。（可见英语多重要。。。）现在看看slice,splice和split分别是啥意思 slice：片 splice： 剪接 split： 分裂 slice：片 可以理解成是提取某东西的片段 用法1：array.slice(start,end) -&gt; 提取数组的片段 简单可以理解成start是提取片段的开头位置(0开始算)，end是提取的末尾位置(1开始算)看例子领会一下 12345678910111213141516171819202122//如果不传入参数二，那么将从参数一的索引位置开始截取，一直到数组尾var a=[1,2,3,4,5,6];var b=a.slice(0,3); //[1,2,3]var c=a.slice(3); //[4,5,6] //如果两个参数中的任何一个是负数，array.length会和它们相加，试图让它们成为非负数，举例说明：//当只传入一个参数，且是负数时，length会与参数相加，然后再截取var a=[1,2,3,4,5,6];var b=a.slice(-1); //[6] //当只传入一个参数，是负数时,并且参数的绝对值大于数组length时，会截取整个数组var a=[1,2,3,4,5,6];var b=a.slice(-6); //[1,2,3,4,5,6]var c=a.slice(-8); //[1,2,3,4,5,6] //当传入两个参数一正一负时，length也会先于负数相加后，再截取var a=[1,2,3,4,5,6];var b=a.slice(2,-3); //[3] //当传入一个参数，大于length时，将返回一个空数组var a=[1,2,3,4,5,6];var b=a.slice(6); //[] 用法2：string.slice(start,end) -&gt; 提取字符串的片段道理同上例子： 12var a=&quot;i am a boy&quot;;var b=a.slice(0,6); //&quot;i am a&quot; splice： 剪接 可以理解成一个东西剪掉一部分并接上新的部分 用法：array.splice(start,deleteCount,item…) 可以理解成array剪掉初始位置为start，个数为deleteCount的部分，该部分赋值给新的变量，如果有item，则接入被剪掉的部分 例子： 12var a=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b=a.splice(1,1,&apos;e&apos;,&apos;f&apos;); //a=[&apos;a&apos;,&apos;e&apos;,&apos;f&apos;,&apos;c&apos;],b=[&apos;b&apos;] split： 分割用法：string.split(separator,limit) 可以理解成把一个东西从第一位置开始根据separator分割成limit个片段来创建一个字符串数组 例子： 12345var a=&quot;0,1,2,3,4,5,6&quot;;var b=a.split(&quot;&quot;,3); // [&quot;0&quot;, &quot;,&quot;, &quot;1&quot;]var a=&quot;0,1,2,3,4,5,6&quot;;var b=a.split(&quot;,&quot;,3); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] ps： join的作用恰好与split相反，是添加组装作用 12var arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;];var b = arr.join(&quot;&quot;);// &quot;012&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx反向代理centos的80端口]]></title>
      <url>%2F2017%2F10%2F14%2FNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86centos%E7%9A%8480%E7%AB%AF%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[最近换了个新的云主机，重新配置了下centos的环境。记录下Nginx反向代理centos的80端口的流程。 HTTP请求是80端口，但是在Linux上非root权限是无法使用1024以下端口的，并且因为安全原因，最好不要使用root权限登录服务器，所以无法直接用node.js程序监听80端口。因此我们需要使用Nginx给node.js做反向代理，将80端口指向应用程序监听的端口(如node.js默认的3000端口)。 添加Nginx仓库 yum install epel-release 2.下载Nginx yum install nginx 3.启用nginx服务 service nginx start 4.添加开机启动 systemctl enable nginx 5.修改Nginx配置文件 vi /etc/nginx/nginx.conf 6.进入配置文件后修改下 123456789101112131415161718192021 server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.hxvin.com,hxvin.com; /#修改这一行（写上你绑定的域名） root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123;proxy_pass http://127.0.0.1:4000; # 添上这一行（端口号写你nodejs运行的端口号） &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 7.测试配置文件是否能够正确运行 nginx -t 123[root@jdu4e00u53f7 ~]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 出现这样，证明配置成功 8.重启nginx service nginx restart 现在直接在浏览器中输入我们配置的域名就可以访问我们的项目了。 ps:如果你用的云主机是国内的，那么你的域名必须先备案才能访问，不然只能域名加后端端口号访问了，如www.hxvin.com:4000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web移动端开发总结3--抓包工具篇(Charles)]]></title>
      <url>%2F2017%2F10%2F11%2Fweb%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%933-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%AF%87-Charles%2F</url>
      <content type="text"><![CDATA[开发过程中经常使用Charles来抓取网页的接口，方便调试。 这边推荐两篇教程 教程1：mac环境下使用Charles抓包Https请求链接 教程2：抓包并篡改返回数据图文详解(有了这个，调试时你就不用麻烦后端给你调整接口的数据)链接 抓包工具不仅可以调试的时候用，还有其他用途，比如抓别人网站或者app的接口，然后做个高仿demo玩玩😄]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web移动端开发总结2--调试篇]]></title>
      <url>%2F2017%2F10%2F10%2Fweb%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%932-%E8%B0%83%E8%AF%95%E7%AF%87%2F</url>
      <content type="text"><![CDATA[web移动端开发的调试分ios设备和安卓设备。 ios设备：1.在ios设备上点击 设置—Safari—高级—web检查器 2.用数据线连接mac电脑 3.ios设备上用Safari打开你要调试的网页 4.打开电脑端的safari点击顶栏的开发—鼠标放在你的设备名称上—点击你要调试的网页 5.跳出web检查器，进行调试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web移动端开发总结1--适配篇]]></title>
      <url>%2F2017%2F10%2F10%2Fweb%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%931-%E9%80%82%E9%85%8D%E7%AF%87%2F</url>
      <content type="text"><![CDATA[在公司主要写web移动端的项目，一开始较大的感触就是适配很麻烦，分ios和安卓，安卓生态又混乱得很，所以适配要做好了，不然这个设备好好的，有些设备却页面错乱。 在网上找了很多方案，踩了不少坑。 方案一： 123456789101112131415161718192021222324252627282930(function (doc, win) &#123; console.log(&quot;dpr:&quot;+win.devicePixelRatio); var docEle = doc.documentElement, isIos = navigator.userAgent.match(/iphone|ipod|ipad/gi), dpr=Math.min(win.devicePixelRatio, 3); scale = 1 / dpr, resizeEvent = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;; docEle.dataset.dpr = dpr; var metaEle = doc.createElement(&apos;meta&apos;); metaEle.name = &apos;viewport&apos;; metaEle.content = &apos;initial-scale=&apos; + scale + &apos;,maximum-scale=&apos; + scale; docEle.firstElementChild.appendChild(metaEle); var recalCulate = function () &#123; var width = docEle.clientWidth; if (width / dpr &gt; 640) &#123; width = 640 * dpr; &#125; docEle.style.fontSize = 20 * (width / 750) + &apos;px&apos;; &#125;; recalCulate() if (!doc.addEventListener) return; win.addEventListener(resizeEvent, recalCulate, false); &#125;)(document, window); 获取设备dpr算出缩放比例 scale = 1/dpr创建meta以及属性将scale值赋给initial-scale，maximum-scalemeta插入到文档中创建屏幕大小改变重新计算函数并监听 特点：这个方案根据设备等比例缩放，每个设备显示内容一致。 缺点：当我用这套方案时，有个问题，因为监听resizeEvent，导致页面打开会先内容变大，然后再正常显示，很是影响用户体验。参考链接 方案二（推荐）： 123456789101112131415161718192021222324252627282930313233//获取屏幕比例function sreenRatio() &#123; const ua = navigator.userAgent; const matches = ua.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i); const UCversion = ua.match(/U3\/((\d+|\.)&#123;5,&#125;)/i); const isUCHd = UCversion &amp;&amp; parseInt(UCversion[1].split(&apos;.&apos;).join(&apos;&apos;), 10) &gt;= 80; const isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi); var dpr = window.devicePixelRatio || 1; if (!isIos &amp;&amp; !(matches &amp;&amp; matches[1] &gt; 534) &amp;&amp; !isUCHd) &#123; // 如果非iOS, 非Android4.3以上, 非UC内核, 就不执行高清, dpr设为1; dpr = 1; &#125; return dpr;&#125;//初始化屏幕比例function screenRatio(baseFontSize, fontscale) &#123; var ratio = sreenRatio(); var scale = document.createElement(&apos;meta&apos;); var scaleRatio = 1 / ratio; scale.name = &apos;viewport&apos;; scale.content = &apos;width=device-width,&apos;+&apos;initial-scale=&apos; + scaleRatio + &apos;, maximum-scale=&apos; + scaleRatio + &apos;, minimum-scale=&apos; + scaleRatio + &apos;, user-scalable=no&apos;; var s = document.getElementsByTagName(&apos;title&apos;)[0]; s.parentNode.insertBefore(scale, s); var _baseFontSize = baseFontSize || 100; var _fontscale = fontscale || 1; document.documentElement.style.fontSize = _baseFontSize / 2 * ratio * _fontscale+&apos;px&apos;;&#125; if (window.screen.width &gt;= 768) &#123; screenRatio(100, 1.5);//字体放大1.5倍 &#125; else &#123; screenRatio(); &#125; 特点： 引用简单，布局简便 根据设备屏幕的DPR,自动设置最合适的高清缩放。 保证了不同设备下视觉体验的一致性。（老方案是，屏幕越大元素越大；此方案是，屏幕越大，看的越多） 有效解决移动端真实1px问题（这里的1px 是设备屏幕上的物理像素）ps：而且不会出现方案一的问题 缺点：1.有可能会出现字体会不受控制的变大的情况，解决方法：css加上一下内容 1*, *:before, *:after &#123; max-height: 100000px &#125; 感觉没啥问题了，然而我司测试硬生生发现一个bug -&gt; 在某安卓设备发现在QQ上打开网页出现页面错乱。解决方法：判断如果是安卓设备，scale.content加上target-densitydpi=device-dpi 修正： 123456789101112131415161718192021222324252627282930313233343536373839404142 //获取屏幕比例 function sreenRatio() &#123; const ua = navigator.userAgent; const matches = ua.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i); const UCversion = ua.match(/U3\/((\d+|\.)&#123;5,&#125;)/i); const isUCHd = UCversion &amp;&amp; parseInt(UCversion[1].split(&apos;.&apos;).join(&apos;&apos;), 10) &gt;= 80; const isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi); var dpr = window.devicePixelRatio || 1; if (!isIos &amp;&amp; !(matches &amp;&amp; matches[1] &gt; 534) &amp;&amp; !isUCHd) &#123; // 如果非iOS, 非Android4.3以上, 非UC内核, 就不执行高清, dpr设为1; dpr = 1; &#125; return dpr; &#125; //初始化屏幕比例 function screenRatio(baseFontSize, fontscale) &#123; var ratio = sreenRatio(); var scale = document.createElement(&apos;meta&apos;); var scaleRatio = 1 / ratio; scale.name = &apos;viewport&apos;; &lt;%/*安卓设备兼容*/%&gt; if (/Android/i.test(navigator.userAgent) == true) &#123; scale.content = &apos;width=device-width, target-densitydpi=device-dpi,&apos;+&apos; initial-scale=&apos; + scaleRatio + &apos;, maximum-scale=&apos; + scaleRatio + &apos;, minimum-scale=&apos; + scaleRatio + &apos;, user-scalable=no&apos;; &lt;%/*iOS设备*/%&gt; &#125; else &#123; scale.content = &apos;width=device-width,&apos;+&apos;initial-scale=&apos; + scaleRatio + &apos;, maximum-scale=&apos; + scaleRatio + &apos;, minimum-scale=&apos; + scaleRatio + &apos;, user-scalable=no&apos;; &#125; var s = document.getElementsByTagName(&apos;title&apos;)[0]; s.parentNode.insertBefore(scale, s); var _baseFontSize = baseFontSize || 100; var _fontscale = fontscale || 1; document.documentElement.style.fontSize = _baseFontSize / 2 * ratio * _fontscale+&apos;px&apos;; &#125;var isAndroid = /Android/i.test(navigator.userAgent) ? true : false;&lt;%/*安卓设备不做高清放大处理*/%&gt; if (window.screen.width &gt;= 768 &amp;&amp; !isAndroid) &#123; screenRatio(null, 1.5);&lt;%/*字体放大1.5倍*/%&gt; &#125; else &#123; screenRatio(); &#125; 参考链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地mysql客户端连接centos的数据库]]></title>
      <url>%2F2017%2F10%2F01%2F%E6%9C%AC%E5%9C%B0mysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5centos%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[最近觉得用终端修改centos数据库有点麻烦，所以用本地mysql客户端可视化 进入centos的数据库 mysql -u root -h localhost -p 使用数据库 use mysql; 赋予远程权限 GRANT ALL PRIVILEGES ON . TO ‘root’@’%’ IDENTIFIED BY ‘password’ WITH GRANT OPTION; 让权限立即生效 flush privileges; –解释其中root表示用户名，%表示所有的电脑都可以连接，也可以设置某个ip地址运行连接，password表示密码 然后在本地的mysql客户端连接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录下node项目部署上线的过程及坑]]></title>
      <url>%2F2017%2F09%2F15%2F%E8%AE%B0%E5%BD%95%E4%B8%8Bnode%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%9D%91%2F</url>
      <content type="text"><![CDATA[前言这个月利用空余时间写的xmxz在修了n多bug之后，在填了不少坑之后终于把他部署到云服务器上线了。对我这个技术菜简直就是挖坑，填坑，挖坑，填坑。。。。。。现在趁还记得一些，记录一下，免得下次忘了 nodejs写爬虫，论坛系统说到nodejs，肯定离不开异步，我在项目中用的是promise+async/await这一套异步方案 async/await是写异步代码的新方式，以前的方法有回调函数和Promise。async/await是基于Promise实现的，它不能用于普通的回调函数。async/await与Promise一样，是非阻塞的。async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 了解回调函数是什么 了解异步与同步，阻塞与非阻塞 Async/Await替代Promise的6个理由 Async/Await详解 show code： 操作mysql 1234567891011121314151617181920212223242526272829let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; resolve( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;let findDataByUser = function ( name ) &#123; let _sql = ` SELECT * from posts where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125; 控制器： 123456789101112131415Post:async(ctx,next)=&gt;&#123; if (ctx.request.querystring) &#123; await userModel.findDataByUser(decodeURIComponent(ctx.request.querystring.split(&apos;=&apos;)[1])) .then(result=&gt;&#123; var string=JSON.stringify(result); res=JSON.parse(string).reverse(); &#125;) await ctx.render(&apos;post&apos;,&#123; session:ctx.session, posts:res &#125;) &#125; &#125; 购买，部署云服务器1.服务器购买我买的是京东云的学生机，选的是centos7.2（国内用centos多一点） 2.服务器登陆通过ssh方式登陆服务器$ ssh root@192.168.1.112 //格式:ssh用户名@公网IP 3.部署nodejs / 部署nodejsps:部署node环境我使用NVM安装多版本 上传项目文件我用的是FileZilla 这个ftp可视化客户端直接去官网下载安装然后输入主机名（你买的云服务器的公网ip） ，用户名（默认是root），密码（你设的云服务器密码）还有端口22 。然后连接。想上传啥直接拖拽就行了，记得先把项目里的node包删掉，不然文件数量分分钟上万。。。。上传到猴年马月。 正确姿势-&gt;删除node包，在云服务器中 npm i 部署mysql如果想简单快速搞定mysql部署的可以用centos6.5centos7以上的版本部署mysql有点麻烦但是呢，对新鲜技术充满鸡血的我还是入坑centos7.2😂 1.确认你的系统环境 1# cat /etc/redhat-release 2.安装mysql 123#yum install mysql#yum install mysql-devel#yum install mysql-server 如果你是centos7以上版本，你会发现安装mysql-server会失败 12345678[root@yl-web yl]# yum install mysql-serverLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.sina.cn * extras: mirrors.sina.cn * updates: mirrors.sina.cnNo package mysql-server available.Error: Nothing to do 原因是CentOS 7 版本将MySQL数据库软件从默认的程序列表中移除，用mariadb代替了。 解决办法 123# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm# rpm -ivh mysql-community-release-el7-5.noarch.rpm# yum install mysql-community-server 安装成功后重启mysql服务。 1# service mysqld restart 初次安装mysql，root账户没有密码。 12345678910111213141516171819202122232425[root@yl-web yl]# mysql -u root Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.6.26 MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.01 sec)mysql&gt; 设置密码方案1 1234mysql&gt; set password for &apos;root&apos;@&apos;localhost&apos; =password(&apos;password&apos;);Query OK, 0 rows affected (0.00 sec)mysql&gt; 不需要重启数据库即可生效。 设置密码方案2（此方案将提高mysql安全性） 1sudo mysql_secure_installation 这将提示您输入默认的根密码。一旦您输入，您将需要更改它。接下去选择yes or no参考这个连接 登录mysql 1# mysql -u root -p 输入密码 如果是这样的 1mysql&gt; 则说明没问题了 最后mariadb自动替换了，将不再生效。 1# rpm -qa |grep mariadb 参考：文章1文章2 然后要修改mysql可以查这些语法链接 附带一个定心丸，如果mysql安装失败了要先彻底删除mysql 用这方法-&gt; centos下彻底删除MYSQL 和重新安装MYSQL 另外一个看起来还可以的教程 这里我还用了pm2这个进程管理器，证进程永远都活着（刚好外加一些模块可以让我的爬虫程序每天定时爬取）安装 1npm install -g pm2 启动 1pm2 start app.js 其他pm2指令教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对付反爬虫战略]]></title>
      <url>%2F2017%2F09%2F10%2F%E5%AF%B9%E4%BB%98%E5%8F%8D%E7%88%AC%E8%99%AB%E6%88%98%E7%95%A5%2F</url>
      <content type="text"><![CDATA[一开始我的反爬思路是这样的： 1.设置几秒请求一次（这边还可以对请求头处理假装浏览器访问） 2.对付验证码 接入打码平台。 下载验证码 上传验证码 获取验证码字符 填写验证码 说起爬虫，真是磕磕绊绊… 前段时间想着即将成为大四狗了，校招如火如荼，本前端狗刚好学了点后端技术（nodejs，PHP），那就用技术做点有意义的事，爬虫爬取厦门地区的校招信息（大概完成）（之后再爬个宣讲信息），然后建个招聘信息发布（已完成），求职交流系统（已完成），然后再造一些求职工具（代做），如简历生成器。时间充沛的话用socket.ioc写一个求职线上交流平台（实习狗时间一直很捉急）。 讲了些有的没的，开始说爬虫过程。 首先，爬虫思路是这样，先把我要爬的网站打开，看想要爬什么，我是爬一个校招网站。先把该内容的首页的文章列表根据分类一个一个爬下来，其中你会看到里面可以爬到每篇文章的url，然后就是访问通过这些url，把每篇文章的具体内容爬取下来，接着就是存到数据库了。 思路是不是很简单？！这种菜鸟级别的爬虫适合我这菜鸟…第一次基本把近五百条具体内容爬下来了，很受鼓舞…不知道玩到第几次，忽然还没爬到一百条就挂了，刷新网站才知道，被怀疑是爬虫，需要填验证码。 好好好，验证码是吧，我去找解决办法，疯狂Google，总结如下，分免费的和付费的。免费的就是用Tesseract开源的OCR识别工具识别验证码，当然还需要graphicsmagick这个图像处理工具的辅助来提高基本的识别率，然并卵….清晰简单的验证码识别率还行，那个校招网站的验证码我试了下，正确率惨不忍睹….是可以去训练tesseract，提高相近字符的识别率…有大把空余时间了再说吧，前端大把东西等我去研究呢。付费的就是让打码平台帮你识别验证码，这个之后可以考虑。 实践一 当然，怎么可以一下子就屈服呢，至少要挣扎反抗到无力嘛。开始了反反爬虫，一开始，我有点小屈服，最新的校招信息能爬下来就行，甚至做了最后的退路—让用户直接点击链接跳转到具体的网，我就展示校招大体信息就好。之前写出来爬虫的效果是日期靠后的那些能爬下来，这个简单，用articleList.reverse()反转组数，这样就把最新的校招信息爬下来了，然而，只爬了六十几篇。。羞愧。。。 实践二 想想对方的反爬虫技术是根据啥来判断是爬虫然后弹出验证码，可能根据ip，短时间请求次数等等，相对更换不同IP地址，短时间请求次数实验成本更低。。然后我给爬虫程序加了定时器setTimeout()，6秒发送一次请求。结果爬了九十多篇。。。这么久爬一次竟然没啥用。。。不科学(@ο@) 。 实践三 换个思路，会不会除了对时间访问次数的判断，还加了如果相隔访问时间一致的话也被判为爬虫的判断？ 那我发送请求的相隔时间就 随机嘛， 1234vartime=Math.floor(Math.random()*(6-1)+1);vardelay=time*1000; 1-5秒随机发送请求。 结果。。。。可以了！！！！！ 六百多（更新得越来越多了）篇文章全爬下来了 看来就是根据访问时间和频率来判断的。 以防ip被封，我把请求头 然后，爬虫总不能每天都手动去点爬虫开关吧，借用这两个第三方模块可以定时执行任务 varspawn=require(‘child_process’).spawn; varcronJob=require(‘cron’).CronJob; // 定时执行爬虫 exports.autoUpdate=’30 20 19 *’;// 每天19：20：30 执行一次任务 varjob=newcronJob(config.autoUpdate,function(){ console.log(‘开始执行定时更新任务’); varupdate=spawn(process.execPath,[path.resolve(__dirname,’./model/all.js’)]); update.stdout.pipe(process.stdout); update.stderr.pipe(process.stderr); update.on(‘close’,function(code) { console.log(‘更新任务结束，代码=%d’, code); }); }); job.start(); （本文完）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前后端开发，mvc模式]]></title>
      <url>%2F2017%2F08%2F28%2F%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%8Cmvc%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[实习两个月除了写前端，还写了点后端(nodejs，php)，前阶段自己也写了个前后端的项目，不过没开源。现在记录下自己对全端开发的个人心得(菜鸟入门级别的，错了请大佬们指导更正)。 感觉不管是php还是nodejs，都是差不多的，大概的作用是处理前端的数据请求，处理数据，操作数据库，把数据返回给前端。 用mvc模式去写一个全端站点。 mvc：模型（Model）、视图（View）和控制器（Controller）。 render(view,model) model可以单独抽出来放一个文件夹 这个就是吧model抽出来，调用model方法，返回数据，render到页面。和nodejs一样的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决非chrome浏览器（移动端适用）后退刷新问题]]></title>
      <url>%2F2017%2F08%2F08%2F%E8%A7%A3%E5%86%B3%E9%9D%9Echrome%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E7%94%A8%EF%BC%89%E5%90%8E%E9%80%80%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[写页面时你可能会遇到这个问题，就是用Firefox，Safari，IE等非chrome浏览器，点击浏览器自带的返回键会发现不会刷新页面，因为那时js代码没有执行。 在网上搜到的有的不能用，有的兼容性很差，故自己想了解决方法，核心是利用setInterval的特性。 这样比如下面这种情形：本来只建了一个二维码，新建了一个 新建完用户没有点击你写的返回按钮（图中的完成按钮），而是点击了浏览器自带的返回键 图片中的chrome浏览器只是当演示用，现实中请用非chrome的去感受这个问题比如用firefox点击打开图片示例的网站链接 结果回去页面没有刷新，结果显示还是原来的样子 而如果返回刷新了，会这样（用户体验会不会好些？） 奉上代码 要刷新的页面（如页面A）123456789101112131415161718&lt;script&gt; //chrome自带后退刷新，故不再次刷新 var ua = window.navigator.userAgent; var isChrome = ua.indexOf(&quot;Chrome&quot;) &amp;&amp; window.chrome; if (! isChrome) &#123; //浏览器后退刷新 function reload() &#123; setInterval(function() &#123; //这个定时器返回A页面会继续执行 if (localStorage.reload == &apos;true&apos; ) &#123; //判断是否刷新页面 localStorage.setItem(&apos;reload&apos;,&apos;false&apos;); location.reload() &#125; &#125;, 500) &#125;; reload(); &#125; &lt;/script&gt; 在A页面之后访问的页面（如页面B）添加一下一行代码ps：作为A页面执行刷新功能的开关1localStorage.setItem(&apos;reload&apos;,&apos;true&apos;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react版的抽奖程序&滚动字幕(入门小demo)]]></title>
      <url>%2F2017%2F07%2F18%2Freact%E7%89%88%E7%9A%84%E6%8A%BD%E5%A5%96%E7%A8%8B%E5%BA%8F%26%E6%BB%9A%E5%8A%A8%E5%AD%97%E5%B9%95(%E5%85%A5%E9%97%A8%E5%B0%8Fdemo)%2F</url>
      <content type="text"><![CDATA[因项目需求，需要写一个react的抽奖程序和字幕滚动。本来之前用的是vue，没用过react，而项目组框架用的是react，萌新只能弃vue改学用react了 写完这个入门小demo，也算初识了下react。 老习惯，写了详细的代码注释。 demo地址 更新 ====================== a：增加了抽奖前的判断： 1.当天是否已抽过奖， ‘否’的话进入下一条判断（这里用localstorage储存，获取当天24点时间戳，过了当天24点localstorage储存清除，时间都是获取本地时间，实际应用应采用服务器时间，防止用户修改本地时间来作弊） 2.现在抽奖时间是否在16-17点之间，‘是’的话则开始抽奖 b：增加了react版的字幕滚动 最初版简陋抽奖gif图 抽奖&amp;字幕滚动图 下载运行git clone https://github.com/hxvin/draw.git cd draw npm install npm start 有错的或者不完善的地方恳请指出纠正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从实际项目小谈react生命周期]]></title>
      <url>%2F2017%2F07%2F15%2F%E4%BB%8E%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%B0%88react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[前言 今天写的一个react版的滚动字幕，思路是用js操作展示内容的scrollWidth,然后用setInterval 循环调用function ，function内容大体思路是对文字内容userDOM.style.transform = ‘translateX(-‘+ i +’px)’,每次横向左移动ipx的距离，形成滚动效果，当i&gt;=scrollWidth的时候，将i归零，形成循环滚动。(这里操作了dom，不是很好) 这里先解释一下浏览器scrollWidth，scrollWidth，offsetWidth三种宽度的区别情况1：元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下。scrollWidth=scrollWidth，两者皆为内容可视区的宽度。offsetWidth为元素的实际宽度。情况2：元素的内容超过可视区，滚动条出现和可用的情况下。scrollWidth&gt;clientWidth。scrollWidth为实际内容的宽度。clientWidth是内容可视区的宽度。offsetWidth是元素的实际宽度。 出问题了为了以便调用后端接口前先模拟展示，将静态生成的内容写死的文字内容换成动态加载，还采取了随机生成用户ip和获奖内容，结果获取到的scrollWidth（元素内容的实际宽度，包括被隐藏的部分）只是内容可视区的宽度，显然是不行的，所以无法滚动全部，我们需要的是元素内容的实际宽度。为什么会出现这种情况呢？如果文字内容是静态生成的，内容写死的，并不会出现这种问题。 问题出在哪里？出在动态加载还要考虑到react的生命周期，componentWillMount(将要挂载)-&gt;render(dom渲染)-&gt;componentDidMount(已经挂载)，这个滚动函数写在了componentDidMount中，也就是页面dom结构渲染完了文字内容才开始动态生成，结果scrollWidth抓取到的文字内容是空的，只能获取了内容可视区的宽度。 问题找出来了，该如何解决呢？最简单粗暴的方式就是把动态加载文字内容的函数放在componentWillMount(将要挂载)中，在render页面之前就把该部分内容加载完毕，这样render页面的时候scrollWidth将抓取到早已加载好的文字内容了，可是这样会造成打开页面后，页面空白一会，在渲染出页面的内容来，这段空白期间就是componentWillMount加载你的数据内容去了。如果数据内容少还好说，万一量很大了，那就尴尬了，严重影响用户体验。 ####更好的解决办法是仍把动态加载文字内容的函数放在componentDidMount中，并在此采用window.onload 调用滚动函数，也就是等页面都渲染完了，文字内容也ok了，才会调用滚动函数（scrollWidth，setInterval，transform ）。 这下，解决了生命周期以及用户体验，加载性能的问题。😀 如有错误和不足，恳请指出指导^ ^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js图片预加载]]></title>
      <url>%2F2017%2F07%2F10%2Fjs%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[继上一次的图片懒加载，这次讲下js实现图片预加载。 先上demo demo:图片预加载 再上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; (function () &#123; function loadImages(sources, callback) &#123; var count = 0, images = &#123;&#125;, imgNum = 0; for (src in sources) &#123; imgNum++; //imgNum =2 &#125; for (src in sources) &#123; //src 为 img1和img2 images[src] = new Image(); //images = &#123;img1:img,img2:img&#125; images[src].onload = function () &#123; //onload 事件会在页面或图像加载完成后立即发生 if (++count &gt;= imgNum) &#123; //当次数大于等于2次时 callback(images); //调用loadImages的回调函数 &#125; &#125; images[src].src = sources[src]; //img1-&gt; img.src = &quot;http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg&quot;;img2同理 &#125; &#125; //存储图片链接信息的关联数组 var sources = &#123; //想要多少张就放多少张 img1: &quot;http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg&quot;, img2: &quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;, img3:&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; &#125;; //调用图片预加载函数，实现回调函数 loadImages(sources, function (images) &#123; //TO-DO something (如下面用canvas把图画出来) //var images = new Image(); 创建一个&lt;img&gt;元素 // images.src = &apos;myImage.png&apos;; 设置图片源地址 var canvas = document.getElementById(&apos;canvas&apos;); var ctx = canvas.getContext(&apos;2d&apos;); //ctx.drawImage(image, dx, dy, dWidth, dHeight); ctx.drawImage(images.img1, 20, 20, 100, 100); ctx.drawImage(images.img2, 140, 20, 100, 100); ctx.drawImage(images.img3, 260, 20, 100, 100); &#125;); &#125;()); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;1000px&quot; height=&quot;1000px&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; 可以看出代码注释很详细，如果有些知识点还不是很清楚，请看我找的一些好的知识讲解文章,省得像我一样到处找啦； 同时，如果您觉得有点帮助，可以关注给我的github项目给个start，watch哦，我会不定期更新js的一些开发常用的知识点技能。 js开发常见技能收集-&gt;github onload for in 遍历 Image 元素构造器 为何使用++count 如何使用canvas创建图片 canvas的drawImage() 如有错误，恳请指出指导^ ^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[公司团队开发git分支管理]]></title>
      <url>%2F2017%2F07%2F08%2F%E5%85%AC%E5%8F%B8%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[前言 从台湾回来那天刚好HR姐姐通知我隔天去公司面试，经过一下午四个面试官的面试之后(讲道理我司面试效率很高👍)，开心地收到公司的实习offer，现在懵逼地上了一周的班。。。。。懵逼的原因是自己太菜了。公司的前端要求具备全栈能力，而我不懂后端吗，所以增哥让我这几天学下php，yaf(php框架)，koa(node js框架)。然后就是熟悉团队开发流程，前端，后端，测试，运维。。。git分支管理代码提交。。。。等，新奇的一周，好多技术可以学，好开心，哈哈哈~~(这里着重感谢增哥大神不厌其烦地指导我) git分支管理策略学习这里可以看看廖雪峰老师写的教程，写得挺好的。廖雪峰git分支管理策略 我们的git分支管理流程git分支管理对团队协作开发真的好用，我们是这样做的。 1.把项目clone到本地，然后建一个自己的子分支，自己就在子分支上写你的代码； 2.写完了提交(commit) 3.把dev分支合并(merge)到自己的分支上看有没有冲突，这样如果有冲突就直接在自己的分支上解决掉 4.check out到dev分支，把自己没问题的分支合并(merge)到dev分支上 5.push dev分支 6.你的上级check一下，觉得没问题就合并到origin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片懒加载及节流函数优化性能]]></title>
      <url>%2F2017%2F06%2F24%2F%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%2F</url>
      <content type="text"><![CDATA[为啥要用图片懒加载对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。 原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求（指向默认的一张图那就只需请求一次）。可以指向loading的地址。 当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 ps：图片要指定宽高 关于窗口各种宽度，给出网上找的一张好图 如果仍不是很理解，看这两篇文章 scrollWidth,clientWidth,offsetWidth的区别 JS中关于clientWidth offsetWidth scrollWidth 等的含义 图片懒加载的实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;&quot; data-src=&quot;http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt;&lt;script&gt; (function()&#123; let num = document.getElementsByTagName(&apos;img&apos;).length; let img = document.getElementsByTagName(&quot;img&quot;); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute(&quot;src&quot;) == &quot;&quot;) &#123; img[i].src = img[i].getAttribute(&quot;data-src&quot;); &#125; n = i + 1; &#125; &#125; &#125; &#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用节流函数进行优化如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。 同时还有以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。 1.window对象的resize、scroll事件 2.拖拽时的mousemove事件 3.射击游戏中的mousedown、keydown事件 4.文字输入、自动完成的keyup事件 解决这个问题的方法有去抖动和节流的方法 去抖动原理： 当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 不足:当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了 节流原理：预设一个执行周期，如果这个周期结束了都还没触发函数，那就会执行一次函数；如果这个周期还没结束就触发了函数，那定时器将重置，开始新周期。 达到了想要的效果，既没有频繁的执行也没有延迟执行 详细可看此文关于js函数节流和去抖动 运用节流函数的图片懒加载代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;&quot; data-src=&quot;http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt;&lt;script&gt; (function()&#123; let num = document.getElementsByTagName(&apos;img&apos;).length; let img = document.getElementsByTagName(&quot;img&quot;); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute(&quot;src&quot;) == &quot;&quot;) &#123; img[i].src = img[i].getAttribute(&quot;data-src&quot;); &#125; n = i + 1; &#125; &#125; &#125; 采用了节流函数 function throttle(fun, delay, time) &#123; let timeout, startTime = new Date(); return function() &#123; let context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) &#123; fun.apply(context, args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125; else &#123; timeout = setTimeout(fun, delay); &#125; &#125;;&#125;;window.addEventListener(&apos;scroll&apos;,throttle(lazyload,500,1000)); &#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js浅拷贝与深拷贝]]></title>
      <url>%2F2017%2F06%2F18%2Fjs%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
      <content type="text"><![CDATA[深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。 浅拷贝 123456789101112var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址。 导致的结果就是：12shallowObj.arr[1] = 5;obj.arr[1] // = 5 深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 深拷贝（这个函数可以深拷贝对象和数组） 123456789101112131415var deepCopy = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== &apos;object&apos;)&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === &apos;object&apos; ? deepCopy(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 结果是： 1234var obj = &#123; a:1, arr: [1,2] &#125;;var deepObj = deepCopy(obj);deepObj.arr[1]=5;obj.arr[1]; //2 本文参考地址。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图文解析HTMLElement.offsetHeight,scrollHeight,clientHeight]]></title>
      <url>%2F2017%2F06%2F05%2FHTMLElement-offsetHeight-scrollHeight-clientHeight%2F</url>
      <content type="text"><![CDATA[HTMLElement.offsetHeight是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 通常，元素的offsetHeight是一种衡量标准，包括元素的边框、垂直内边距和元素的水平滚动条（如果存在且渲染的话）和元素的CSS高度。 对于文档的主体对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。 Element.scrollHeightElement.scrollHeight 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的margin. Element.clientHeight返回元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。 clientHeight 可以通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算. 也就是说，是没有垂直滚动条版本的scrollHeight。 更新： clientWidth = width + padding clientHeight = height + padding offsetWidth = width + padding + border offsetHeight = height + padding + border]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac使用tree]]></title>
      <url>%2F2017%2F05%2F30%2Fmac%E4%BD%BF%E7%94%A8tree%2F</url>
      <content type="text"><![CDATA[一、brew安装1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 然后一直按return键即可 二、brew使用brew安装套件： $ brew install tree 常用命令$ tree -a //显示所有文件和目录。 $ tree -d //显示目录名称而非内容 $ tree -L 2 //这个命令是比较实用的，后面的数字2代表几层]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2写单页面项目总结记录]]></title>
      <url>%2F2017%2F05%2F29%2Fpost%E7%94%A8vue%E5%86%99webapp%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%971%2F</url>
      <content type="text"><![CDATA[前言一直想做个有数据内容的项目，刚好vue社区提供了API，在此感谢。这是一个基于vue+vue-cli+vue-router+axios+webpack开发的vue社区SPA;UI用Muse-UI;css用scss，flex布局，rem做移动端适配，最终效果电脑端移动端都适配。 如果你和我一样用vue还挺生疏的，那好好做完这个项目，会学到很多东西，能有挺大的进步，还可以自己加功能，一起(๑•̀ㅂ•́)و✧加油。 如果对您有帮助，请给一个star鼓励一下萌新，感谢 ^ ^如果您也是前端萌新，来互相follow互相学习，一起进步呀。 建议先去社区注册拿accesstoken登录体验(注册可以直接用github账号，挺快的) demo 点击查看gif动图展示 github项目地址 项目API 完成功能 [x] 首页列表 [x] 下拉加载 [x] 用户信息（点击头像） [x] 主题内容 [x] 登录功能 [x] 收藏（取消收藏）主题 [x] 评论列表 [x] 点赞（取消点赞）功能 [x] 消息中心（已读、未读） [x] 个人中心 [x] 发表评论 [x] 回复评论 [x] 发布主题（支持markdown格式,可预览） todo功能 [ ] 左右侧滑 [ ] 搜索功能 [ ] vuex重构 准备开发环境 $ npm install -g vue-cli $ vue init webpack vue-home ? Project name vue-home ? Project description vue-home ? Author afei ? Vue build standalone ? Install vue-router? Yes ? Use ESLint to lint your code? No ? Setup unit tests with Karma + Mocha? No ? Setup e2e tests with Nightwatch? No $ cd vue-home $ npm install $ npm run dev等写完项目后 $ npm run build 注意：npm run dev 之后 默认浏览器打开的是http://localhost:8080 请换成http://localhost:8080/vue-home/dist如果你电脑的8080端口被占用，请congfig/index.js中找到port: 8080修改成8081或者其他可用的端口 开始动手项目结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546├── build│ ├── build.js│ ├── check-versions.js│ ├── dev-client.js│ ├── dev-server.js│ ├── utils.js│ ├── vue-loader.conf.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── dist //等写完项目后 $ npm run build 的打包文件│ ├── index.html│ └── static├── index.html //首页入口文件├── node_modules├── package.json ├── src│ ├── App.vue //项目入口文件│ ├── assets│ │ ├── 1495982696.png //手机扫描二维码│ │ ├── logo.png //vue logo│ │ └── sass //sass通用样式│ ├── components //组件│ │ ├── FooterNav.vue //底部nav组件│ │ ├── HeaderBar.vue //顶部横条│ │ ├── HeaderTabs.vue //顶部tabs组件&amp;主页面内容拉取│ │ └── Hello.vue │ ├── main.js //核心文件 在这里引入了Muse UI 时间过滤器│ ├── pages //页面│ │ ├── content.vue //帖子内容页面 │ │ ├── index.vue //首页│ │ ├── login.vue //登录页面│ │ ├── message.vue //信息通知页面│ │ ├── more.vue │ │ ├── my.vue //个人信息页面│ │ ├── people.vue //社区用户信息页面│ │ └── publish.vue //发布帖子页面(此页面还没写完)│ ├── router //路由与组件配置│ │ └── index.js │ └── util //时间过滤器，转换时间格式│ └── filter.js└── static vue-home/config/index.js assetsPublicPath: &#39;/vue-home/dist&#39; 这个公共路径原本为assetsPublicPath: ‘/‘，这样在本地服务器是可以跑，可是打包上传到github后会发现打开的页面是空白的，报错如下图。 原因是路径错了，vue-home是项目文件夹名称，dist是npm run build之后出现的文件夹，github上线就是读取dist文件夹而生成的网页（成功展示的demo地址长这样：http://www.hxvin.me/vue-home/dist/） 解决上线路径问题不知道还有没有其他更方便的解决方法，如果有，请跟我讲下哦 port: 8080 这个是让你改端口的 vue-home/src/App.vue rem适配移动端，1rem=10px 1234html&#123; font-size: 62.5%; &#125; 建议注释掉这段，不然会然干扰后面的css 123/*text-align: center;*//*color: #2c3e50;margin-top: 60px;*/ /vue-home/index.html 我们是做的移动端，适配web端，所以在index.html里面加上meta 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=0&quot;&gt; 用MuseUI的添加之一 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot;&gt; vue-home/src/main.js 图中有标识了哪些是用来干嘛的，分别是用MuseUI的添加之一；filters是用来把社区api数据中的时间格式转换成*分钟前``*小时前``*天前 关于新建主题功能api上写了需post title String 标题 tab String 目前有 ask share job content String 主体内容 记得还需要传递accesstoken的参数，不然会报403错误（资源不可用） markdown格式支持 直接 npm install marked –save 用法详见代码 （代码好像用文章不方便介绍，我很详细地写了代码注释哦^_^）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS函数方法坑与填坑]]></title>
      <url>%2F2017%2F05%2F17%2FJS%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%9D%91%E4%B8%8E%E5%A1%AB%E5%9D%91%2F</url>
      <content type="text"><![CDATA[首先，先认识下什么叫函数的方法：在一个对象中绑定函数，称为这个对象的方法。 再给具体的例子：1234567891011var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 27 xiaoming是一个对象，age（）函数就是该对象的方法。此时this指向xiaoming 如果拆开写：123456789101112131415function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: getAge&#125;;xiaoming.age(); // 27, 正常结果getAge(); // NaNvar fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 以对象的方法形式调用没问题，该函数的this指向被调用的对象xiaomign； 你会发现单独调用getAge()函数返回NaN,该函数的this指向全局对象，也就是window，这是JS的一个坑。 填坑：1. 要保证this指向正确，必须用obj.xxx()的形式调用！这里需注意：obj.xxx()也不是什么情况下都适用的，比如在在函数内定义的函数： 1234567891011121314151617181920212223242526272829303132&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property &apos;birth&apos; of undefined填坑：&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 27 2.或者用apply()和call()方法修复函数调用：函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。如：12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2的todolist入门小项目的详细解析]]></title>
      <url>%2F2017%2F05%2F09%2Fvue2%E7%9A%84todolist%E5%85%A5%E9%97%A8%E5%B0%8F%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[看完vue2的官方文档后，找个入门项目巩固下知识点，简单的todolsit是个不错的选择。项目用到了vue.js vue.cli webpack ES6 node环境，完成项目后会对这些技术栈有了些了解。 准备开发环境 $ npm install -g vue-cli $ vue init ，比如 vue init webpack todolist $ cd todolist $ npm install $ npm run dev 安装谷歌插件vue.js devtools 下载vue.js的webpack模板 下载 todomvc的模板 (提供html和css)（也可以直接$ git clone https://github.com/tastejs/todomvc-app-template.git 来下载） 把todomvc的index.html拖到todolist文件夹去覆盖里面的index.html 打开todomvc的json文件，会看到 “todomvc-app-css”: “^2.0.0”,就是要你 npm install todomvc-app-css -S 从而下载该css 删点todolsit index.html的默认css，js引用，src文件夹下的main.js引入模板css（import‘todomvc-app-css/index.css’） 引入vue（import Vue form ‘vue’） 等写完代码后 $npm run build 一键打包构建，会看到dist文件夹 main.js的代码 //后面的为注释讲解， ~表示串联index.html的对应内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import &apos;todomvc-app-css/index.css&apos;import Vue from &apos;vue&apos;//添加localStoragevar STORAGE_KEY = &apos;todos-vuejs-2.0&apos;var todoStorage = &#123; fetch: function () &#123; var todos = JSON.parse(localStorage.getItem(STORAGE_KEY) || &apos;[]&apos;) todos.forEach(function (todo, index) &#123; todo.id = index &#125;) todoStorage.uid = todos.length return todos &#125;, save: function (todos) &#123; localStorage.setItem(STORAGE_KEY, JSON.stringify(todos)) &#125;&#125;//用过滤器筛选出三种状态var filters = &#123; all(todos) &#123; return todos &#125;, active(todos) &#123; return todos.filter((todo) =&gt; &#123; return !todo.completed &#125;) &#125;, completed(todos) &#123; return todos.filter((todo) =&gt; &#123; return todo.completed &#125;) &#125;,&#125;let app = new Vue(&#123; el: &apos;.todoapp&apos;, // ~ &lt;section class=&quot;todoapp&quot;&gt; data: &#123; msg: &apos;hello world&apos;, title: &apos;待做清单&apos;, // 渲染标题 ~ &#123;&#123;title&#125;&#125; newTodo: &apos;&apos;, todos: todoStorage.fetch(), // ~ v-show=&quot;todos.length&quot; ； ~ &#123;&#123;todos.length&gt;1?&apos;items&apos;:&apos;item&apos;&#125;&#125; 渲染 li ~ v-for=&quot;(todo,index) in filteredTodos&quot; editedTodo: &apos;&apos;, // 空的编辑对象 hashName: &apos;all&apos; &#125;, watch: &#123; todos: &#123; handler: function (todos) &#123; todoStorage.save(todos) &#125;, deep: true &#125; &#125;, computed: &#123; remain() &#123; return filters.active(this.todos).length //未完成事项的数量 ~ &#123;&#123;remain&#125;&#125; &#125;, isAll: &#123; // ~ v-model=&quot;isAll&quot; get() &#123; return this.remain === 0 &#125;, set(value) &#123; this.todos.forEach((todo) =&gt; &#123; todo.completed = value &#125;) &#125; &#125;, filteredTodos() &#123; //用hashName过滤出当前页面的todos ~ v-for=&quot;(todo,index) in filteredTodos&quot; return filters[this.hashName](this.todos) &#125; &#125;, methods: &#123; addTodo(e) &#123; //输入值为空时，不添加（trim去除前后空格） ~ v-model.trim=&quot;newTodo&quot; if (!this.newTodo) &#123; return &#125; this.todos.push(&#123; id: todoStorage.uid++, content: this.newTodo, completed: false //结合v-model 根据completed状态绑定样式 ~:class=&quot;&#123;completed:todo.completed； ~ v-model=&quot;todo.completed&quot; &#125;) this.newTodo = &apos;&apos; &#125;, removeTodo(index) &#123; //绑定x样式，点击删除该todo ~ @click=&quot;removeTodo(index)&quot; this.todos.splice(index, 1) &#125;, editTodo(todo) &#123; //编辑 ~ @dblclick=&quot;editTodo(todo)&quot; this.editCache = todo.content //储存编辑前的内容 this.editedTodo = todo // 点击编辑里面的内容而不是只是空文本框~ editing:todo==editedTodo&#125;&quot; &#125;, doneEdit(todo, index) &#123; //失去焦点后 ~ @blur=&quot;doneEdit(todo)&quot;；@keyup.enter=&quot;doneEdit(todo)&quot; this.editedTodo = null //不存在编辑了或者说编辑已完成 if (!todo.content) &#123; //如果编辑后没有内容了，删除该todo this.removeTodo(index) &#125; &#125;, cancelEdit(todo) &#123; //按esc键取消此次编辑操作 ~ @keyup.esc=&quot;cancelEdit(todo)&quot;&gt; this.editedTodo = null todo.content = this.editCache //当esc取消编辑时，还原编辑前的内容 &#125;, clear() &#123; //点击清除已完成的功能 ~ @click=&quot;clear&quot; this.todos = filters.active(this.todos) //获取并渲染未完成的事项 ~ &#125; &#125;, directives: &#123; //自定义属性 ~ v-focus=&quot;todo == editedTodo&quot; focus(el, value) &#123; //文本框双击获取焦点 if (value) &#123; el.focus() &#125; &#125; &#125;&#125;)//hash（url地址中#以及之后的字符）function hashChange() &#123; // ~ :class=&quot;&#123;selected:hashName==&apos;all&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;active&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;completed&apos;&#125;&quot; let hashName = location.hash.replace(/#\/?/, &apos;&apos;) //正则表达式去除#/？，获取如all，active，completed if (filters[hashName]) &#123; //如果过滤状态的hashName存在 app.hashName = hashName //给整个app变量里的hashName赋上那个值 &#125; else &#123; location.hash = &apos;&apos; //取消 app.hashName = &apos;all&apos; //否则就赋值‘all’，回到全部事项的页面 &#125;&#125;window.addEventListener(&apos;hashchange&apos;, hashChange) //全局监听hash]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue学习]]></title>
      <url>%2F2017%2F05%2F08%2FVue%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[此文章用来不断记录Vue学习过程中一知半解知识点的总结，fighting~ 组件：可以扩展 HTML 元素，封装可重用的代码 理解父组件，子组件 v-model：使用 v-model 来进行数据双向绑定，根据控件类型自动选取正确的方法来更新元素，负责监听用户的输入事件以更新数据 理解数据单向绑定，双向绑定 钩子： hook形象解释 生命周期： 生命周期形象解释]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>%2F2017%2F04%2F29%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最好的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算因此很多现代的算法教科书避免使用冒泡排序，而用插入排序替换之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最好的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。 冒泡排序算法的运作如下：（两个for循环差不多搞定） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。 12345678910111213141516function bubbleSort(arr)&#123;if(arr.length&lt;=1)&#123; return arr; &#125; for(var j=0;j&lt;arr.length;j++)&#123; for( var i = 0; i&lt;arr.length-j;i++)&#123; if(arr[i] &gt; arr[i+1])&#123; var num = arr[i]; arr[i] = arr[i+1]; arr[i+1] = num; &#125; &#125; &#125; return arr; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[轻松学习JS快速排序(QuickSort)]]></title>
      <url>%2F2017%2F04%2F29%2F%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0JS%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort%2F</url>
      <content type="text"><![CDATA[需了解的基础知识 1.递归函数：编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。 一个典型阶乘递归函数： 1234567function fact(num)&#123; if (num&lt;=1)&#123; return 1; &#125;else&#123; return num*fact(num-1); &#125; &#125; 该函数的弊端： 123var another=factorical;factorical=null;console.log(another(2))//会报错说 factorical not a function 解决方法: 用arguments.callee去代替函数名，就可以确保函数不管怎么调用都不会出错。 1234567891011function factorical(num)&#123; if(num&lt;=1)&#123; return 1; &#125; else&#123; return num*arguments.callee(num-1); &#125;&#125;var another=factorical;factorical=null;console.log(another(2))//2 (来自js高程) 2.JavaScript中的splice方法用法详解 3.JavaScript concat()方法 3.Javascript之Math对象详解 步骤以下内容整理自阮一峰老师的快速排序（Quicksort）的Javascript实现 首先，定义一个quickSort函数，它的参数是一个数组。 var quickSort = function(arr) { 然后，检查数组的元素个数，如果小于等于1，就返回。 if (arr.length &lt;= 1) { return arr; } 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1); var left = []; var right = []; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。 for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } 最后，使用递归不断重复这个过程，就可以得到排序后的数组。 return quickSort(left).concat([pivot], quickSort(right));}; 使用的时候，直接调用quickSort()就行了。 最终的快排函数123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1); var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 实例运用12var array = [7,4,1,9,6,3,2,5,8] ;quickSort(array); //输出1，2，3，4，5，6，7，8，9]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发中js数组的常用方法]]></title>
      <url>%2F2017%2F04%2F27%2F%E5%BC%80%E5%8F%91%E4%B8%ADjs%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在ES5中，一共有9个Array方法： Array.prototype.indexOf;Array.prototype.lastIndexOf;Array.prototype.every;Array.prototype.some;Array.prototype.forEach;Array.prototype.map;Array.prototype.filter;Array.prototype.reduce;Array.prototype.reduceRight; 5种比较常用=&gt;index(),filter(),forEach(),map(),reduce(). ps:reduce()还没搞懂，就先不整理了。文末有个实例了解实际运用。 介绍1) indexOfindexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。不使用indexOf时： 123456789var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],found = false; for(var i= 0, l = arr.length; i&lt; l; i++)&#123;if(arr[i] === &apos;a&apos;)&#123;found = true;&#125;&#125;console.log(&quot;found:&quot;,found);//输出found: true indexOf使用后 123var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; console.log(&quot;found:&quot;, arr.indexOf(&quot;a&quot;) != -1);//输出found: true 2) filter该filter()方法创建一个新的匹配过滤条件的数组。 不用 filter() 时 12345678910111213141516var arr = [ [&quot;a&quot;, 2], [&quot;b&quot;, 5], [&quot;c&quot;, 3], [&quot;b&quot;, 16],]; var newArr = []; for(var i= 0, l = arr.length; i&lt; l; i++)&#123; if(arr[i][0] == &quot;b&quot; )&#123;newArr.push(arr[i]);&#125;&#125; alert(newArr);//输出b,5,b,16 用了 filter(): 1234567891011var arr = [ [&quot;a&quot;, 2], [&quot;b&quot;, 5], [&quot;c&quot;, 3], [&quot;b&quot;, 16],]; var newArr = arr.filter(function(element, index, array)&#123; return element[0] == &quot;b&quot; ;&#125;); alert(newArr); //输出b,5,b,16 3) forEach()forEach为每个元素执行对应的方法,用来替换for循环 不用 forEach() 时 1234var arr = [1,2,3,4,5,6,7,8];for(var i= 0, l = arr.length; i&lt; l; i++)&#123;console.log(arr[i]); //输出 1 2 3 4 5 6 7 8 &#125; 用了forEach() 1234var arr = [1,2,3,4,5,6,7,8];arr.forEach(function(element, index, array)&#123;console.log(element);//输出 1 2 3 4 5 6 7 8 &#125;); 4) map()map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组，不使用mapmap()是处理服务器返回数据时是一个非常实用的函数。 不用 map() 时 12345678910111213141516var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;]; function getNewArr()&#123; var newArr = []; for(var i= 0, l = oldArr.length; i&lt; l; i++)&#123; var item = oldArr[i]; full_name = [item.first_name,item.last_name].join(&quot; &quot;); newArr[i] = full_name; &#125; return newArr;&#125; console.log(getNewArr());//输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;] 使用map后 123456789101112var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;]; function getNewArr()&#123; return oldArr.map(function(item,index)&#123; full_name = [item.first_name,item.last_name].join(&quot; &quot;); return full_name; &#125;); &#125; console.log(getNewArr()); //输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;] 百度IFE的js任务(二)的运用传送门任务描述:参考以下示例代码，页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上 实现思路：1、用filter()方法筛选出值大于60的城市赋值给一个新的数组。2、用sort()对这个新的数组进行由大到小的排序。3、用forEach()代替for循环并动态创建li标签并打印名次和城市及其空气质量值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;污染城市列表&lt;/h3&gt; &lt;ul id=&quot;aqi-list&quot;&gt;&lt;!-- &lt;li&gt;第一名：福州（样例），10&lt;/li&gt; &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; --&gt; &lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt;var aqiData = [ [&quot;北京&quot;, 90], [&quot;上海&quot;, 50], [&quot;福州&quot;, 10], [&quot;广州&quot;, 50], [&quot;成都&quot;, 90], [&quot;西安&quot;, 100]];(function () &#123; /* 在注释下方编写代码 遍历读取aqiData中各个城市的数据 将空气质量指数大于60的城市显示到aqi-list的列表中 */ var aqiul=document.getElementById(&apos;aqi-list&apos;); //获取数组 //用filter()方法筛选出空气质量指数大于60的数组 var filtered = aqiData.filter(function(element, index, array)&#123; return (element[1] &gt;= 60); &#125;) ; filtered.sort(function(a,b)&#123; //从大到小排序 return b[1]-a[1]; &#125;); // (function wirte()&#123; //输出 用for循环 // for(var i=0;i&lt;filtered.length;i++)&#123; // var li=document.createElement(&apos;li&apos;); // aqiul.append(li); // li.innerHTML=&quot;第&quot;+(i+1)+&quot;名：&quot;+filtered[i]; // &#125; // &#125;)();//用forEach方法代替for循环 filtered.forEach(function(element, index, array)&#123; var li=document.createElement(&apos;li&apos;); aqiul.append(li); li.innerHTML=&quot;第&quot;+(index+1)+&quot;名：&quot;+filtered[index]; &#125;);&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于自执行函数（立即执行函数）]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%88%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[什么是自执行函数？一下有三种写法 1.最前最后加括号1(function()&#123;alert(1);&#125;()); 这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如： 12var a=1 (function()&#123;alert(1);&#125;()); 2.function外面加括号 1(function()&#123;alert(1);&#125;)(); 这种做法比方法1少了一个代码整体性的好处. 3.function前面加运算符，常见的是!与void 。 12!function()&#123;alert(1);&#125;(); void function()&#123;alert(2);&#125;(); 显然，加上“!”或“+”等运算符，写起来是最简单的。加上“void ”要敲五下键盘，但是听说有一个好处是，比加”!”少一次逻辑运算。 首先声明一个匿名函数 function(){alert(‘我是匿名函数’)}。 然后在匿名函数后面接一对括号 ()，调用这个匿名函数。 自执行函数的作用创建一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」） 例子来看一个著名的面试题： 123456var liList = ul.getElementsByTagName(&apos;li&apos;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是6,而不是0、1、2、3、4、5 &#125;&#125; 为什么 alert 的总是 6 呢? 因为 i 是贯穿整个作用域的，而不是给每个li 分配了一个i,如下： 那么怎么解决这个问题呢？ 用立即执行函数给每个li创造一个独立作用域即可（当然还有其他办法）： 12345678var liList = ul.getElementsByTagName(&apos;li&apos;)for(var i=0; i&lt;6; i++)&#123; !function(ii)&#123; liList[ii].onclick = function()&#123; alert(ii) // 0、1、2、3、4、5 &#125; &#125;(i)&#125; 在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。 (整理自网络)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于this对象的一个易错点]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9%2F</url>
      <content type="text"><![CDATA[先给一个例子123456789101112var name = &quot;The Window&quot;var object = &#123; name : &quot;My Object&quot;, f1 : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.f1()()); 这个例子返回的字符串是 “The Window”，为啥不是”My Object”呢？ 原因是每个函数在被调用时， 其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变最时， 只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 也就是说要想让闭包【return function(){}】访问到外部函数【f1 :function(){}】里的this（或者arguments）变量，就要先将其赋值给到一个闭包能够访问到的变量里，如var that = this，这样就可以了。 修改后的例子如下12345678910111213var name = &quot;The Window&quot;var object = &#123; name : &quot;My Object&quot;, f1 : function()&#123; var that = this; //添加这行 return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.f1()()); 返回”My Object” 另外一个例子1234567var name = &quot;The Window•;var object = &#123; name : &quot;My Object&quot;; getName: function() &#123; return this.name; &#125; &#125;; 上一个例子中的return function(){ return this.name；}被换掉了，不再是闭包 123object.getName(); //&apos;My Object&apos;(object.getName)(); //&apos;My Object&quot;(object.getName = object.getNamel (); //&quot;The Window•, 在非严格模式下 第一行代码跟平常一样词用了object.getName (), 返回的是飞y Object”, 因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后， 就好􀉀只是在引用一个函数， 但this的值得到了维持， 因为objec七.getName 和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再诮用赋值后的结果。因为这个赋值表达式的值是函数本身， 所以this的值不能得到维持， 结果就返回了崎The Window飞]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(二)]]></title>
      <url>%2F2017%2F04%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[继承概念OO语言中支持两种继承方式：实现继承，接口继承 实现继承：继承实际的方法 接口继承：继承函数签名 由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的原型链 原型链的问题（缺点） 1、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 2、在创建子类型的实例时，不能向超类型的构造函数中传递参数 默认的原型 所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。 如何确定原型和实例之间的关系 1、通过instanceof:测试实例与原型链中出现过的构造函数，结果会返回true 12345678910 alert(instance instanceof Object) //true alert(instance instanceof SuperType) //true alert(instance instanceof Subtype) //true ``` * 2、isPropertyOf()方法：只要是原型链中出现过的原型，都会返回true``` alert(Object.prtotype.isPropertyOf(instance)) //true alert(SuperType.prtotype.isPropertyOf(instance)) //true alert(Subtype.prtotype.isPropertyOf(instance)) //true 定义方法时要注意的几个问题 场景：子类型优势需要覆盖超类型中的某个方法，或者需要添加类型中不存在的某个方法 2、不能通过对象字面量方法添加新方法（因为会重写原型链） 1、给子类型添加方法的代码一定要放在替换原型的语句之后（否则会因为重新定义了原型而导致添加代码无效） 基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法例子：12345678910111213function SuperType()&#123; this.SuperProperty = true; &#125;; SuperType.prototype.getSuperProperty = function()&#123;return this.SuperProperty&#125;; function SubType()&#123; this.SubProperty = false; &#125;; SubType.prototype = new SuperType(); SubType.prototype.getSubProperty = function()&#123;return this.getSubProperty&#125;; var instance = new SubType(); alert(instance.getSuperProperty()) //true 借用构造函数缺点 1、方法都在构造函数中定义，函数无法复用，每个方法都是function的一个新实例 2、在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 传递参数 优点：借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数 123456789101112131415161718192021 function SuperType (name) &#123;function this.name= name; &#125; function SubType () &#123; //继承了Super&apos;l&apos;ype, 同时还传递了参数 superType.call(this, &quot;Nicholas&quot;); //实例属性 this.age= 29;&#125; var instance= new SubType(); alert(instance.name) ; //“Nicholas” alert(instance.age); //29 ``` #### 基本思想：在子类型构造函数中调用超类型构造函数 ``` function SuperType()&#123; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; function SubType()&#123; SuperType.call(this); &#125;; 组合继承概念 1、将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，又叫伪经典继承 2、基本思想：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承 3.是JavaScript中最常用的继承模式 优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式function SuperType(name){12345678910111213141516171819202122232425262728293031323334 this.name = name; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name)&#123; SuperType.call(this,name); this.age = age; &#125;; SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; ``` ### 原型式继承 #### Object.creat() * 参数一 * 用作新对象原型的对象 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person); ``` * 参数二 * 为新对象定义额外属性的对象（以这种方式指定的任何属性都会覆盖原型对象上的同名属性），注意格式 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person,&#123; name:&#123; value:&quot;Greg&quot; &#125; &#125;); ECMAScipt5通过新增的Object.create()规范化了原型式继承 核心12345function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; 例子123var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =object(person); //person成为了anotherPerson的原型 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。缺点：不能实现函数复用12345function creatAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123;alert(&quot;Hi&quot;)&#125;; return clone; &#125; 在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题 组合继承例子： 1234567891011121314function SuperType(name)&#123; //超类型构造函数 this.name=name; this.color=&#123;&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; SuperType.prototype.sayName=function()&#123; alert(this.name); function SubType(name,age)&#123; SuperType.call(this,name) //第二次调用 this.age = age; &#125; SubType.prototype = new SuperType(); //第一次调用 SubType.prototype.construtor =SuperType; SubType.protptype.sayAge =function()&#123; alert(this.age) 这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变123456 function inheritPrototype(subType,superType)&#123; //prototype成为superType的一个副本，而不用调用构造函数 var prototype = SuperType.prototype; prototype.constructor = SubType; SubType.prototype = prototype; &#125;; 例子12345678910111213141516function SuperType(name)&#123; this.name = name; &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(Subtype,SuperType); SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; function inheritPrototype(SubType，SuperType)&#123; var prototype = object(SuperType.prototype);//创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype ;//指定对象 &#125; 在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor屈性，从而弥补因重写原型而失去的默认的constructor属性。最后一步， 将新创建的对象（即副本）赋值给子类型的原型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[添加畅言评论]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[多说评论听说要关闭了，大家都在找评论系统替换。我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。 步骤教程写在简书上了，就不搬过来啦 简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[justjavac的知乎live听后总结]]></title>
      <url>%2F2017%2F04%2F23%2Fjustjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[get点： 1.跟别人互相review代码。2.系统学习js。多写算法相关的，少写特效。如写一个计算器。3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。 5.面试官会根据你写在简历里的东西提问。6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。7.扎实基础再去学框架8.移动端不用jQuery9.与其做很多项目，不如做精一个两项目。10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。11.对于学习，首选是看书，系统的全面的学。推荐的书：《黑客与画家》《javascript高级程序设计》《javascript精粹》《你不知道的javascript》推荐的网站：MDN等等。。。。。很多 讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔试整理(1)]]></title>
      <url>%2F2017%2F04%2F18%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1%2F</url>
      <content type="text"><![CDATA[1.CSS的某些样式是具有继承性的什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 2.对象的深拷贝与浅拷贝的区别 浅拷贝：仅仅复制对象的引用，而不是对象本身；深拷贝：把复制的对象所引用的全部对象都复制一遍。 浅拷贝例子： ================ 浅拷贝 ================ */1234567891011121314151617181920212223242526272829303132333435function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for ( var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj;&#125;客户端调用/* ================ 客户端调用 ================ */var obj = &#123; a: &quot;hello&quot;, b: &#123; a: &quot;world&quot;, b: 21 &#125;, c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;], d: function() &#123; alert(&quot;hello world&quot;); &#125;&#125;var cloneObj = simpleClone(obj); // 对象拷贝 console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 修改拷贝后的对象cloneObj.b.a = &quot;changed&quot;;cloneObj.c = [1, 2, 3];cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;; console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了 console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改 深拷贝的实现也有很多种方法，这里就介绍Object.create()方法 ================ 深拷贝 ================ */12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === &apos;object&apos;) &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(-)]]></title>
      <url>%2F2017%2F04%2F18%2Fjs%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[理解对象定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数属性类型 数据属性 [[Configurabke]]:能否通过delete删除属性从而重新定义属性 访问器属性 创建对象可以通过“构造函数”或者“对象字面量”方法创建函数 缺点：通过一个接口创建很多对象，会产生大量的重复代码 工厂模式 12345678 function creatPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; return o &#125; var person1 = creatPerson(“hxvin”,21,”F-E”); 用函数来封装以特定接口创建对象的细节 缺点：没有解决对象识别的问题 构造函数模式1234567function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function sayName()&#123;alert(this.name);&#125;; &#125;; var person1=new Person(“hxvin”,21,&quot;Front-end-Engineer&quot;); 和工厂模式的区别： 没有显式的创建对象 直接将属性和方法赋给了this 没有return语句 用这种方式调用构造函数会经历一下四个步骤 执行构造函数中的代码（为这个新对象添加属性） 创建一个新对象 将构造函数的作用域赋给新对象 返回新对象 缺点：每个方法都要在每个实例上创建一遍 上例中sayName方法相当于 this.sayName=new Funciton(“alert(name,age,job)”) 解决方法 12345678 function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName &#125;; function sayName()&#123;alert(this.name);&#125;; //将sayName添加到全局变量中，这样显然有很多不足 原型模式 原型模式 概念 每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以 由特定类型的所有实例共享的属性和方法 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法 创建原型: 12345 function Person()&#123;&#125;; Person.prototype.name=“hxvin”； Person.prototype.sayname=function()&#123; alert(this.name); &#125;； var person1=new Person(); person1.dayName(); //“hxvin” 理解原型 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针 搜索流程 当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性 每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找 hasOwnProperty() 用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true alert(person1 hasOwnProperty(“name”)); //返回true或false [[prototype]] 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象 利用[[prototype]] ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值 支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome 但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系 alert(Person.protoype isPrototypeOf(person1)); //true 没有标准的方式访问[[prototype]] 更简单的原型语法 123456789101112 //可以重新设置constructor function Perspn()&#123;&#125;; Person.prototype=&#123; constructor=Person, name=&quot;Nick&quot; &#125;; function Person()&#123;&#125;; Person.prototype=&#123; name=&quot;Nick&quot;, sayName=function()&#123;alert(this.name)&#125; &#125; 注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数 原型的动态性 注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针） 我们对原型对象所做的任何修改都能够立即从实例上反映出来 原型对象的问题（缺点） 1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值 2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来 组合使用构造函数模式和原型模式 123456789 function Person(name,age,job)&#123; this.name=name, this.age=age, this.job=job &#125;; Person.prototype=&#123; constructor=Person, sayName=function()&#123;alert(this.name)&#125; &#125; Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组 优点 每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存 创建自定义类型最常见的方式 支持向构造函数传递参数 动态原型模式123456789 function Person(name,age,job)&#123; //属性 this.name=name; this.age=age; this.job=job; //方法 if(typeof sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123;alert(this.name)&#125; &#125; &#125; //方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。 这里对原型所做的修改，能够立即在所有实例中得到反映。 把所有信息封装在构造函数中，并通过if语句初始化原型 寄生构造函数模式123456789 function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123;alert(o.name)&#125;; return o &#125;; var person1 = new Person(); 应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数 特点 返回的对象和构造函数没有关系 不能依赖instanceof操作符来确定对象类型 稳妥构造函数模式 所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。 function Person(name,age,job){ var o = new Object(); o.sayName = function(){alert(name)} } var friend = Person (“hxvin”,”21”,”f-e”); friend.sayName(}; //“hxvin” 这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。 这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。 应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用 特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数]]></content>
    </entry>

    
  
  
</search>
