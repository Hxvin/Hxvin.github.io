<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[面向对象的程序设计(二)]]></title>
      <url>%2F2017%2F04%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[继承概念OO语言中支持两种继承方式：实现继承，接口继承 实现继承：继承实际的方法 接口继承：继承函数签名 由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的原型链 原型链的问题（缺点） 1、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 2、在创建子类型的实例时，不能向超类型的构造函数中传递参数 默认的原型 所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。 如何确定原型和实例之间的关系 1、通过instanceof:测试实例与原型链中出现过的构造函数，结果会返回true 12345678910 alert(instance instanceof Object) //true alert(instance instanceof SuperType) //true alert(instance instanceof Subtype) //true ``` * 2、isPropertyOf()方法：只要是原型链中出现过的原型，都会返回true``` alert(Object.prtotype.isPropertyOf(instance)) //true alert(SuperType.prtotype.isPropertyOf(instance)) //true alert(Subtype.prtotype.isPropertyOf(instance)) //true 定义方法时要注意的几个问题 场景：子类型优势需要覆盖超类型中的某个方法，或者需要添加类型中不存在的某个方法 2、不能通过对象字面量方法添加新方法（因为会重写原型链） 1、给子类型添加方法的代码一定要放在替换原型的语句之后（否则会因为重新定义了原型而导致添加代码无效） 基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法例子：12345678910111213function SuperType()&#123; this.SuperProperty = true; &#125;; SuperType.prototype.getSuperProperty = function()&#123;return this.SuperProperty&#125;; function SubType()&#123; this.SubProperty = false; &#125;; SubType.prototype = new SuperType(); SubType.prototype.getSubProperty = function()&#123;return this.getSubProperty&#125;; var instance = new SubType(); alert(instance.getSuperProperty()) //true 借用构造函数缺点 1、方法都在构造函数中定义，函数无法复用，每个方法都是function的一个新实例 2、在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 传递参数 优点：借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数 123456789101112131415161718192021 function SuperType (name) &#123;function this.name= name; &#125; function SubType () &#123; //继承了Super&apos;l&apos;ype, 同时还传递了参数 superType.call(this, &quot;Nicholas&quot;); //实例属性 this.age= 29;&#125; var instance= new SubType(); alert(instance.name) ; //“Nicholas” alert(instance.age); //29 ``` #### 基本思想：在子类型构造函数中调用超类型构造函数 ``` function SuperType()&#123; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; function SubType()&#123; SuperType.call(this); &#125;; 组合继承概念 1、将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，又叫伪经典继承 2、基本思想：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承 3.是JavaScript中最常用的继承模式 优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式function SuperType(name){12345678910111213141516171819202122232425262728293031323334 this.name = name; this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;] &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name)&#123; SuperType.call(this,name); this.age = age; &#125;; SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; ``` ### 原型式继承 #### Object.creat() * 参数一 * 用作新对象原型的对象 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person); ``` * 参数二 * 为新对象定义额外属性的对象（以这种方式指定的任何属性都会覆盖原型对象上的同名属性），注意格式 ``` var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =Object.create(person,&#123; name:&#123; value:&quot;Greg&quot; &#125; &#125;); ECMAScipt5通过新增的Object.create()规范化了原型式继承 核心12345function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; 例子123var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;; var anotherPerson =object(person); //person成为了anotherPerson的原型 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。缺点：不能实现函数复用12345function creatAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123;alert(&quot;Hi&quot;)&#125;; return clone; &#125; 在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题 组合继承例子： 1234567891011121314function SuperType(name)&#123; //超类型构造函数 this.name=name; this.color=&#123;&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; SuperType.prototype.sayName=function()&#123; alert(this.name); function SubType(name,age)&#123; SuperType.call(this,name) //第二次调用 this.age = age; &#125; SubType.prototype = new SuperType(); //第一次调用 SubType.prototype.construtor =SuperType; SubType.protptype.sayAge =function()&#123; alert(this.age) 这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变123456 function inheritPrototype(subType,superType)&#123; //prototype成为superType的一个副本，而不用调用构造函数 var prototype = SuperType.prototype; prototype.constructor = SubType; SubType.prototype = prototype; &#125;; 例子12345678910111213141516function SuperType(name)&#123; this.name = name; &#125;; SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(Subtype,SuperType); SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;; function inheritPrototype(SubType，SuperType)&#123; var prototype = object(SuperType.prototype);//创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype ;//指定对象 &#125; 在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor屈性，从而弥补因重写原型而失去的默认的constructor属性。最后一步， 将新创建的对象（即副本）赋值给子类型的原型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[添加畅言评论]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[多说评论听说要关闭了，大家都在找评论系统替换。我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。 步骤教程写在简书上了，就不搬过来啦 简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[justjavac的知乎live听后总结]]></title>
      <url>%2F2017%2F04%2F23%2Fjustjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[get点： 1.跟别人互相review代码。2.系统学习js。多写算法相关的，少写特效。如写一个计算器。3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。 5.面试官会根据你写在简历里的东西提问。6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。7.扎实基础再去学框架8.移动端不用jQuery9.与其做很多项目，不如做精一个两项目。10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。11.对于学习，首选是看书，系统的全面的学。推荐的书：《黑客与画家》《javascript高级程序设计》《javascript精粹》《你不知道的javascript》推荐的网站：MDN等等。。。。。很多 讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一次笔试，整理(1)]]></title>
      <url>%2F2017%2F04%2F18%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1%2F</url>
      <content type="text"><![CDATA[之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了. 特别想提的一点是在过程中感觉到美图的HR和技术总监为人很 nice，~(≧▽≦)/~赞。** 这几天都在考期中考，所以笔试完也没马上做总结就去准备接下去接连一天一科的期中考了。 笔试有要求题目不能外泄，以下只是自己依稀记得的不大会做，不会做的知识点，仅供补缺补漏使用。 1.CSS的某些样式是具有继承性的什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 2.对象的深拷贝与浅拷贝的区别 浅拷贝：仅仅复制对象的引用，而不是对象本身；深拷贝：把复制的对象所引用的全部对象都复制一遍。 浅拷贝例子： ================ 浅拷贝 ================ */1234567891011121314151617181920212223242526272829303132333435function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for ( var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj;&#125;客户端调用/* ================ 客户端调用 ================ */var obj = &#123; a: &quot;hello&quot;, b: &#123; a: &quot;world&quot;, b: 21 &#125;, c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;], d: function() &#123; alert(&quot;hello world&quot;); &#125;&#125;var cloneObj = simpleClone(obj); // 对象拷贝 console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 修改拷贝后的对象cloneObj.b.a = &quot;changed&quot;;cloneObj.c = [1, 2, 3];cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;; console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了 console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改 深拷贝的实现也有很多种方法，这里就介绍Object.create()方法 ================ 深拷贝 ================ */12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === &apos;object&apos;) &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象的程序设计(-)]]></title>
      <url>%2F2017%2F04%2F18%2Fjs%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[理解对象定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数属性类型 数据属性 [[Configurabke]]:能否通过delete删除属性从而重新定义属性 访问器属性 创建对象可以通过“构造函数”或者“对象字面量”方法创建函数 缺点：通过一个接口创建很多对象，会产生大量的重复代码 工厂模式 12345678 function creatPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; return o &#125; var person1 = creatPerson(“hxvin”,21,”F-E”); 用函数来封装以特定接口创建对象的细节 缺点：没有解决对象识别的问题 构造函数模式1234567function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function sayName()&#123;alert(this.name);&#125;; &#125;; var person1=new Person(“hxvin”,21,&quot;Front-end-Engineer&quot;); 和工厂模式的区别： 没有显式的创建对象 直接将属性和方法赋给了this 没有return语句 用这种方式调用构造函数会经历一下四个步骤 执行构造函数中的代码（为这个新对象添加属性） 创建一个新对象 将构造函数的作用域赋给新对象 返回新对象 缺点：每个方法都要在每个实例上创建一遍 上例中sayName方法相当于 this.sayName=new Funciton(“alert(name,age,job)”) 解决方法 12345678 function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName &#125;; function sayName()&#123;alert(this.name);&#125;; //将sayName添加到全局变量中，这样显然有很多不足 原型模式 原型模式 概念 每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以 由特定类型的所有实例共享的属性和方法 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法 创建原型: 12345 function Person()&#123;&#125;; Person.prototype.name=“hxvin”； Person.prototype.sayname=function()&#123; alert(this.name); &#125;； var person1=new Person(); person1.dayName(); //“hxvin” 理解原型 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针 搜索流程 当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性 每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找 hasOwnProperty() 用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true alert(person1 hasOwnProperty(“name”)); //返回true或false [[prototype]] 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象 利用[[prototype]] ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值 支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome 但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系 alert(Person.protoype isPrototypeOf(person1)); //true 没有标准的方式访问[[prototype]] 更简单的原型语法 123456789101112 //可以重新设置constructor function Perspn()&#123;&#125;; Person.prototype=&#123; constructor=Person, name=&quot;Nick&quot; &#125;; function Person()&#123;&#125;; Person.prototype=&#123; name=&quot;Nick&quot;, sayName=function()&#123;alert(this.name)&#125; &#125; 注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数 原型的动态性 注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针） 我们对原型对象所做的任何修改都能够立即从实例上反映出来 原型对象的问题（缺点） 1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值 2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题） 由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来 组合使用构造函数模式和原型模式 123456789 function Person(name,age,job)&#123; this.name=name, this.age=age, this.job=job &#125;; Person.prototype=&#123; constructor=Person, sayName=function()&#123;alert(this.name)&#125; &#125; Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组 优点 每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存 创建自定义类型最常见的方式 支持向构造函数传递参数 动态原型模式123456789 function Person(name,age,job)&#123; //属性 this.name=name; this.age=age; this.job=job; //方法 if(typeof sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123;alert(this.name)&#125; &#125; &#125; //方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。 这里对原型所做的修改，能够立即在所有实例中得到反映。 把所有信息封装在构造函数中，并通过if语句初始化原型 寄生构造函数模式123456789 function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123;alert(o.name)&#125;; return o &#125;; var person1 = new Person(); 应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数 特点 返回的对象和构造函数没有关系 不能依赖instanceof操作符来确定对象类型 稳妥构造函数模式 所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。 function Person(name,age,job){ var o = new Object(); o.sayName = function(){alert(name)} } var friend = Person (“hxvin”,”21”,”f-e”); friend.sayName(}; //“hxvin” 这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。 这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。 应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用 特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数]]></content>
    </entry>

    
  
  
</search>
