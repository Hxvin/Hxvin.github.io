<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hxvin的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-26T15:43:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hxvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于自执行函数（立即执行函数）</title>
    <link href="http://yoursite.com/2017/04/26/%E5%85%B3%E4%BA%8E%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%88%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/26/关于自执行函数（立即执行函数）/</id>
    <published>2017-04-26T15:42:12.000Z</published>
    <updated>2017-04-26T15:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是自执行函数？"><a href="#什么是自执行函数？" class="headerlink" title="什么是自执行函数？"></a>什么是自执行函数？</h3><p>一下有三种写法</p>
<p>1.最前最后加括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function()&#123;alert(1);&#125;());</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如：</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a=1 </div><div class="line">(function()&#123;alert(1);&#125;());</div></pre></td></tr></table></figure>
<p>2.function外面加括号 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function()&#123;alert(1);&#125;)();</div></pre></td></tr></table></figure>
<blockquote>
<p>这种做法比方法1少了一个代码整体性的好处.</p>
</blockquote>
<p>3.function前面加运算符，常见的是!与void 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">!function()&#123;alert(1);&#125;(); </div><div class="line">void function()&#123;alert(2);&#125;();</div></pre></td></tr></table></figure>
<blockquote>
<p>显然，加上“!”或“+”等运算符，写起来是最简单的。加上“void ”要敲五下键盘，但是听说有一个好处是，比加”!”少一次逻辑运算。</p>
</blockquote>
<p><img src="http://images2015.cnblogs.com/blog/336056/201610/336056-20161011221635859-1560145581.png" alt="自执行函数"></p>
<ul>
<li>首先声明一个匿名函数 function(){alert(‘我是匿名函数’)}。</li>
<li>然后在匿名函数后面接一对括号 ()，调用这个匿名函数。</li>
</ul>
<h3 id="自执行函数的作用"><a href="#自执行函数的作用" class="headerlink" title="自执行函数的作用"></a>自执行函数的作用</h3><p>创建一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」）</p>
<p>例子来看一个著名的面试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var liList = ul.getElementsByTagName(&apos;li&apos;)</div><div class="line">for(var i=0; i&lt;6; i++)&#123;</div><div class="line">  liList[i].onclick = function()&#123;</div><div class="line">    alert(i) // 为什么 alert 出来的总是6,而不是0、1、2、3、4、5</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 为什么 alert 的总是 6 呢?</p>
<blockquote>
<p>因为 i 是贯穿整个作用域的，而不是给每个li 分配了一个i,如下：</p>
</blockquote>
<p><img src="http://images2015.cnblogs.com/blog/336056/201610/336056-20161011221647906-1355610620.png" alt="也是网上的图"></p>
<p> 那么怎么解决这个问题呢？</p>
<blockquote>
<p>用立即执行函数给每个li创造一个独立作用域即可（当然还有其他办法）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var liList = ul.getElementsByTagName(&apos;li&apos;)</div><div class="line">for(var i=0; i&lt;6; i++)&#123;</div><div class="line">  !function(ii)&#123;</div><div class="line">    liList[ii].onclick = function()&#123;</div><div class="line">      alert(ii) // 0、1、2、3、4、5</div><div class="line">    &#125;</div><div class="line">  &#125;(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。</p>
</blockquote>
<p>(整理自网络)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是自执行函数？&quot;&gt;&lt;a href=&quot;#什么是自执行函数？&quot; class=&quot;headerlink&quot; title=&quot;什么是自执行函数？&quot;&gt;&lt;/a&gt;什么是自执行函数？&lt;/h3&gt;&lt;p&gt;一下有三种写法&lt;/p&gt;
&lt;p&gt;1.最前最后加括号&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(function()&amp;#123;alert(1);&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于this对象的一个易错点</title>
    <link href="http://yoursite.com/2017/04/26/%E5%85%B3%E4%BA%8Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9/"/>
    <id>http://yoursite.com/2017/04/26/关于this对象的一个易错点/</id>
    <published>2017-04-26T15:39:31.000Z</published>
    <updated>2017-04-26T15:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先给一个例子"><a href="#先给一个例子" class="headerlink" title="先给一个例子"></a>先给一个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    </div><div class="line">    f1 : function()&#123;</div><div class="line">       return function()&#123;</div><div class="line">           return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">  alert(object.f1()());</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>这个例子返回的字符串是 “The Window”，为啥不是”My Object”呢？</p>
</blockquote>
<ul>
<li>原因是每个函数在被调用时， 其活动对象都会自动取得两个特殊变量：<code>this</code>和<code>arguments</code>。内部函数在搜索这两个变最时， 只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</li>
<li>也就是说要想让闭包【return function(){}】访问到外部函数【f1 :function(){}】里的this（或者arguments）变量，就要先将其赋值给到一个闭包能够访问到的变量里，如var that = this，这样就可以了。</li>
</ul>
<h4 id="修改后的例子如下"><a href="#修改后的例子如下" class="headerlink" title="修改后的例子如下"></a>修改后的例子如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    </div><div class="line">    f1 : function()&#123;</div><div class="line">       var that = this; //添加这行</div><div class="line">       return function()&#123;</div><div class="line">           return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">  alert(object.f1()());</div></pre></td></tr></table></figure>
<blockquote>
<p>返回”My Object”</p>
</blockquote>
<h4 id="另外一个例子"><a href="#另外一个例子" class="headerlink" title="另外一个例子"></a>另外一个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window•;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;;</div><div class="line">    getName: function() &#123;</div><div class="line">         return this.name;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>上一个例子中的<br>return function(){<br>    return this.name；<br>}<br>被换掉了，不再是闭包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object.getName(); //&apos;My Object&apos;</div><div class="line">(object.getName)(); //&apos;My Object&quot;</div><div class="line">(object.getName = object.getNamel (); //&quot;The Window•, 在非严格模式下</div></pre></td></tr></table></figure>
<blockquote>
<p>第一行代码跟平常一样词用了object.getName (), 返回的是飞y Object”, 因为this.name<br>就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后， 就好􀉀只<br>是在引用一个函数， 但this的值得到了维持， 因为objec七.getName 和(object.getName)的定义<br>是相同的。第三行代码先执行了一条赋值语句，然后再诮用赋值后的结果。因为这个赋值表达式的值是<br>函数本身， 所以this的值不能得到维持， 结果就返回了崎The Window飞</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;先给一个例子&quot;&gt;&lt;a href=&quot;#先给一个例子&quot; class=&quot;headerlink&quot; title=&quot;先给一个例子&quot;&gt;&lt;/a&gt;先给一个例子&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name = &amp;quot;The Window&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var object = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name : &amp;quot;My Object&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    f1 : function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           return this.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  alert(object.f1()());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计(二)</title>
    <link href="http://yoursite.com/2017/04/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/25/面向对象的程序设计-二/</id>
    <published>2017-04-25T12:36:34.000Z</published>
    <updated>2017-04-25T13:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="OO语言中支持两种继承方式：实现继承，接口继承"><a href="#OO语言中支持两种继承方式：实现继承，接口继承" class="headerlink" title="OO语言中支持两种继承方式：实现继承，接口继承"></a>OO语言中支持两种继承方式：实现继承，接口继承</h3><ul>
<li>实现继承：继承实际的方法  </li>
<li>接口继承：继承函数签名  </li>
</ul>
<h4 id="由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的"><a href="#由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的" class="headerlink" title="由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的"></a>由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的</h4><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="http://ooytyiziz.bkt.clouddn.com/7895A860-4021-47A7-A343-BBC78A970381.png" alt="原型链"></p>
<a id="more"></a>
<h4 id="原型链的问题（缺点）"><a href="#原型链的问题（缺点）" class="headerlink" title="原型链的问题（缺点）"></a>原型链的问题（缺点）</h4><ul>
<li>1、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题）  </li>
<li>2、在创建子类型的实例时，不能向超类型的构造函数中传递参数  </li>
</ul>
<h4 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h4><ul>
<li>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。  </li>
</ul>
<h4 id="如何确定原型和实例之间的关系"><a href="#如何确定原型和实例之间的关系" class="headerlink" title="如何确定原型和实例之间的关系"></a>如何确定原型和实例之间的关系</h4><ul>
<li>1、通过instanceof:测试实例与原型链中出现过的构造函数，结果会返回true  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	   alert(instance instanceof Object)    //true  </div><div class="line">		alert(instance instanceof SuperType)    //true  </div><div class="line">		alert(instance instanceof Subtype)    //true  </div><div class="line">```  </div><div class="line">* 2、isPropertyOf()方法：只要是原型链中出现过的原型，都会返回true</div><div class="line"></div><div class="line">```  </div><div class="line">	    alert(Object.prtotype.isPropertyOf(instance))    //true  </div><div class="line">		alert(SuperType.prtotype.isPropertyOf(instance))    //true  </div><div class="line">		alert(Subtype.prtotype.isPropertyOf(instance))    //true</div></pre></td></tr></table></figure>
<h4 id="定义方法时要注意的几个问题"><a href="#定义方法时要注意的几个问题" class="headerlink" title="定义方法时要注意的几个问题"></a>定义方法时要注意的几个问题</h4><ul>
<li>场景：子类型优势需要覆盖超类型中的某个方法，或者需要添加类型中不存在的某个方法  </li>
<li>2、不能通过对象字面量方法添加新方法（因为会重写原型链）  </li>
<li>1、给子类型添加方法的代码一定要放在替换原型的语句之后（否则会因为重新定义了原型而导致添加代码无效）  </li>
</ul>
<h4 id="基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法"><a href="#基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法" class="headerlink" title="基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法"></a>基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法</h4><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;  </div><div class="line">    this.SuperProperty = true;  </div><div class="line">&#125;;  </div><div class="line">SuperType.prototype.getSuperProperty = function()&#123;return this.SuperProperty&#125;;  </div><div class="line">  </div><div class="line">function SubType()&#123;  </div><div class="line">    this.SubProperty = false;  </div><div class="line">&#125;;  </div><div class="line">SubType.prototype = new SuperType();  </div><div class="line">SubType.prototype.getSubProperty = function()&#123;return this.getSubProperty&#125;;  </div><div class="line">  </div><div class="line">var instance = new SubType();  </div><div class="line">alert(instance.getSuperProperty()) //true</div></pre></td></tr></table></figure>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>1、方法都在构造函数中定义，函数无法复用，每个方法都是function的一个新实例  </li>
<li>2、在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式  </li>
</ul>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><ul>
<li>优点：借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  function SuperType (name) &#123;function   </div><div class="line">	this.name= name;  </div><div class="line">	&#125;  </div><div class="line">	function SubType () &#123;  </div><div class="line">	//继承了Super&apos;l&apos;ype, 同时还传递了参数  </div><div class="line">	superType.call(this, &quot;Nicholas&quot;);  </div><div class="line">	//实例属性  </div><div class="line">	this.age= 29;&#125;  </div><div class="line">	var instance= new SubType();  </div><div class="line">	alert(instance.name) ; //“Nicholas” alert(instance.age); //29  </div><div class="line">	</div><div class="line">```  </div><div class="line">#### 基本思想：在子类型构造函数中调用超类型构造函数  </div><div class="line"></div><div class="line">```  </div><div class="line">    function SuperType()&#123;  </div><div class="line">    this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]      </div><div class="line">&#125;;  </div><div class="line">function SubType()&#123;  </div><div class="line">    SuperType.call(this);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>1、将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，又叫伪经典继承  </li>
<li>2、基本思想：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承  </li>
<li>3.是JavaScript中最常用的继承模式  </li>
</ul>
<h4 id="优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性"><a href="#优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性" class="headerlink" title="优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性"></a>优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性</h4><h4 id="组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式"><a href="#组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式" class="headerlink" title="组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式"></a>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式</h4><h4 id="function-SuperType-name"><a href="#function-SuperType-name" class="headerlink" title="function SuperType(name){"></a>function SuperType(name){</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    this.name = name;  </div><div class="line">    this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]  </div><div class="line">&#125;;  </div><div class="line">SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;;  </div><div class="line">function SubType(name)&#123;  </div><div class="line">    SuperType.call(this,name);  </div><div class="line">    this.age = age;  </div><div class="line">&#125;;  </div><div class="line">SubType.prototype = new SuperType();  </div><div class="line">SubType.prototype.constructor = SubType;  </div><div class="line">SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;;  </div><div class="line"></div><div class="line">```  </div><div class="line">### 原型式继承  </div><div class="line">  </div><div class="line">#### Object.creat()  </div><div class="line">  </div><div class="line">* 参数一  </div><div class="line">	* 用作新对象原型的对象 </div><div class="line"></div><div class="line">``` </div><div class="line">	 var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;;  </div><div class="line">		var anotherPerson =Object.create(person);  </div><div class="line">```  </div><div class="line">* 参数二  </div><div class="line">	* 为新对象定义额外属性的对象（以这种方式指定的任何属性都会覆盖原型对象上的同名属性），注意格式</div><div class="line">	</div><div class="line">```  </div><div class="line">	   var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;;  </div><div class="line">		var anotherPerson =Object.create(person,&#123;  </div><div class="line">		    name:&#123;  </div><div class="line">		    value:&quot;Greg&quot;  </div><div class="line">		    &#125;  </div><div class="line">		&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>ECMAScipt5通过新增的Object.create()规范化了原型式继承  </li>
</ul>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;  </div><div class="line">    function F()&#123;&#125;;  </div><div class="line">    F.prototype = o;  </div><div class="line">    return new F();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;;  </div><div class="line">var anotherPerson =object(person);  </div><div class="line">//person成为了anotherPerson的原型</div></pre></td></tr></table></figure>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><h4 id="寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。"><a href="#寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。" class="headerlink" title="寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。"></a>寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</h4><h4 id="缺点：不能实现函数复用"><a href="#缺点：不能实现函数复用" class="headerlink" title="缺点：不能实现函数复用"></a>缺点：不能实现函数复用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function creatAnother(original)&#123;  </div><div class="line">    var clone = object(original);  </div><div class="line">    clone.sayHi = function()&#123;alert(&quot;Hi&quot;)&#125;;  </div><div class="line">    return clone;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。"><a href="#在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。" class="headerlink" title="在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。"></a>在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。</h4><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><h4 id="所谓寄生组合式继承，即通过借用构造函数来继承属性，-通过原型链的混成形式来继承方法。"><a href="#所谓寄生组合式继承，即通过借用构造函数来继承属性，-通过原型链的混成形式来继承方法。" class="headerlink" title="所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。"></a>所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。</h4><h4 id="基本思路：-不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。"><a href="#基本思路：-不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。" class="headerlink" title="基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。"></a>基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</h4><h4 id="目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题"><a href="#目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题" class="headerlink" title="目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题"></a>目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题</h4><ul>
<li>组合继承例子：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;  //超类型构造函数  </div><div class="line">	    this.name=name;  </div><div class="line">	    this.color=&#123;&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]  </div><div class="line">	  &#125;  </div><div class="line">	 SuperType.prototype.sayName=function()&#123;  </div><div class="line">	 alert(this.name);  </div><div class="line">	 function SubType(name,age)&#123;  </div><div class="line">	     SuperType.call(this,name) //第二次调用  </div><div class="line">	     this.age = age;  </div><div class="line">	 &#125;  </div><div class="line">	 SubType.prototype = new SuperType(); //第一次调用  </div><div class="line">	 SubType.prototype.construtor =SuperType;  </div><div class="line">	 SubType.protptype.sayAge =function()&#123;  </div><div class="line">	     alert(this.age)</div></pre></td></tr></table></figure>
<h4 id="这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变"><a href="#这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变" class="headerlink" title="这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变"></a>这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   function inheritPrototype(subType,superType)&#123;  </div><div class="line">    //prototype成为superType的一个副本，而不用调用构造函数  </div><div class="line">    var prototype = SuperType.prototype;  </div><div class="line">    prototype.constructor = SubType;  </div><div class="line">    SubType.prototype = prototype;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;  </div><div class="line">    this.name = name;  </div><div class="line">&#125;;  </div><div class="line">SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;;  </div><div class="line">function SubType(name,age)&#123;  </div><div class="line">    SuperType.call(this,name);  </div><div class="line">    this.age = age;  </div><div class="line">&#125;  </div><div class="line">inheritPrototype(Subtype,SuperType);  </div><div class="line">SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;;  </div><div class="line"></div><div class="line">    function inheritPrototype(SubType，SuperType)&#123;   </div><div class="line">      var prototype = object(SuperType.prototype);//创建对象  </div><div class="line">     prototype.constructor = subType;//增强对象  </div><div class="line">      subType.prototype = prototype ;//指定对象  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor屈性，从而弥补因重写原型而失去的默认的constructor属性。最后一步， 将新创建的对象（即副本）赋值给子类型的原型。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;OO语言中支持两种继承方式：实现继承，接口继承&quot;&gt;&lt;a href=&quot;#OO语言中支持两种继承方式：实现继承，接口继承&quot; class=&quot;headerlink&quot; title=&quot;OO语言中支持两种继承方式：实现继承，接口继承&quot;&gt;&lt;/a&gt;OO语言中支持两种继承方式：实现继承，接口继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实现继承：继承实际的方法  &lt;/li&gt;
&lt;li&gt;接口继承：继承函数签名  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&quot;&gt;&lt;a href=&quot;#由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&quot; class=&quot;headerlink&quot; title=&quot;由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&quot;&gt;&lt;/a&gt;由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&lt;/h4&gt;&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ooytyiziz.bkt.clouddn.com/7895A860-4021-47A7-A343-BBC78A970381.png&quot; alt=&quot;原型链&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>添加畅言评论</title>
    <link href="http://yoursite.com/2017/04/25/%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA/"/>
    <id>http://yoursite.com/2017/04/25/添加畅言评论/</id>
    <published>2017-04-24T16:48:36.000Z</published>
    <updated>2017-04-24T17:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多说评论听说要关闭了，大家都在找评论系统替换。"><a href="#多说评论听说要关闭了，大家都在找评论系统替换。" class="headerlink" title="多说评论听说要关闭了，大家都在找评论系统替换。"></a>多说评论听说要关闭了，大家都在找评论系统替换。</h4><h4 id="我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。"><a href="#我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。" class="headerlink" title="我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。"></a>我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。</h4><h4 id="而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。"><a href="#而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。" class="headerlink" title="而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。"></a>而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。</h4><blockquote>
<p>步骤教程写在简书上了，就不搬过来啦</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/5888bd91d070" target="_blank" rel="external">简书</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;多说评论听说要关闭了，大家都在找评论系统替换。&quot;&gt;&lt;a href=&quot;#多说评论听说要关闭了，大家都在找评论系统替换。&quot; class=&quot;headerlink&quot; title=&quot;多说评论听说要关闭了，大家都在找评论系统替换。&quot;&gt;&lt;/a&gt;多说评论听说要关闭了，大家都在找评
    
    </summary>
    
    
      <category term="-其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>justjavac的知乎live听后总结</title>
    <link href="http://yoursite.com/2017/04/23/justjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/23/justjavac的知乎live听后总结/</id>
    <published>2017-04-23T00:11:12.000Z</published>
    <updated>2017-04-24T15:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>get点：</strong></p>
<blockquote>
<p>1.跟别人互相review代码。<br>2.系统学习js。多写算法相关的，少写特效。如写一个计算器。<br>3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。<br>4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>5.面试官会根据你写在简历里的东西提问。<br>6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。<br>7.扎实基础再去学框架<br>8.移动端不用jQuery<br>9.与其做很多项目，不如做精一个两项目。<br>10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。<br>11.对于学习，首选是看书，系统的全面的学。<br>推荐的书：<br>《黑客与画家》<br>《javascript高级程序设计》<br>《javascript精粹》<br>《你不知道的javascript》<br>推荐的网站：MDN<br>等等。。。。。很多</p>
</blockquote>
<p><strong><em>讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;get点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.跟别人互相review代码。&lt;br&gt;2.系统学习js。多写算法相关的，少写特效。如写一个计算器。&lt;br&gt;3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。&lt;br&gt;4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="-学习总结" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>第一次笔试，整理(1)</title>
    <link href="http://yoursite.com/2017/04/18/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1/"/>
    <id>http://yoursite.com/2017/04/18/第一次笔试，整理-1/</id>
    <published>2017-04-18T10:11:12.000Z</published>
    <updated>2017-04-25T12:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了.</strong></p>
<a id="more"></a>
<blockquote>
<p>特别想提的一点是在过程中感觉到美图的HR和技术总监为人很 <code>nice</code>，~(≧▽≦)/~赞。**</p>
</blockquote>
<p><strong>这几天都在考期中考，所以笔试完也没马上做总结就去准备接下去接连一天一科的期中考了。</strong></p>
<p><strong><em>笔试有要求题目不能外泄，以下只是自己依稀记得的不大会做，不会做的知识点，仅供补缺补漏使用。</em></strong></p>
<h3 id="1-CSS的某些样式是具有继承性的"><a href="#1-CSS的某些样式是具有继承性的" class="headerlink" title="1.CSS的某些样式是具有继承性的"></a>1.CSS的某些样式是具有继承性的</h3><p><strong>什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。</strong></p>
<blockquote>
<p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）<br>所有元素可继承：visibility和cursor。<br>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。<br>终端块状元素可继承：text-indent和text-align。<br>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。<br>表格元素可继承：border-collapse。</p>
</blockquote>
<!-- more -->
<h3 id="2-对象的深拷贝与浅拷贝的区别"><a href="#2-对象的深拷贝与浅拷贝的区别" class="headerlink" title="2.对象的深拷贝与浅拷贝的区别"></a>2.对象的深拷贝与浅拷贝的区别</h3><blockquote>
<p>浅拷贝：仅仅复制对象的引用，而不是对象本身；<br>深拷贝：把复制的对象所引用的全部对象都复制一遍。</p>
</blockquote>
<p><strong>浅拷贝例子：</strong></p>
<figure class="highlight plain"><figcaption><span>================ 浅拷贝 ================ */</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function simpleClone(initalObj) &#123;</div><div class="line">    var obj = &#123;&#125;;</div><div class="line">    for ( var i in initalObj) &#123;</div><div class="line">        obj[i] = initalObj[i];</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">客户端调用</div><div class="line">/* ================ 客户端调用 ================ */</div><div class="line">var obj = &#123;</div><div class="line">    a: &quot;hello&quot;,</div><div class="line">    b: &#123;</div><div class="line">        a: &quot;world&quot;,</div><div class="line">        b: 21</div><div class="line">    &#125;,</div><div class="line">    c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;],</div><div class="line">    d: function() &#123;</div><div class="line">        alert(&quot;hello world&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var cloneObj = simpleClone(obj); // 对象拷贝</div><div class="line"> </div><div class="line">console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;</div><div class="line">console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]</div><div class="line">console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125;</div><div class="line"> </div><div class="line">// 修改拷贝后的对象</div><div class="line">cloneObj.b.a = &quot;changed&quot;;</div><div class="line">cloneObj.c = [1, 2, 3];</div><div class="line">cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;;</div><div class="line"> </div><div class="line">console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了</div><div class="line"> </div><div class="line">console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改</div><div class="line">console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改</div></pre></td></tr></table></figure>
<p><strong>深拷贝的实现也有很多种方法，这里就介绍Object.create()方法</strong></p>
<figure class="highlight plain"><figcaption><span>================ 深拷贝 ================ */</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function deepClone(initalObj, finalObj) &#123;</div><div class="line">    var obj = finalObj || &#123;&#125;;</div><div class="line">    for (var i in initalObj) &#123;</div><div class="line">        var prop = initalObj[i];</div><div class="line">        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</div><div class="line">        if(prop === obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (typeof prop === &apos;object&apos;) &#123;</div><div class="line">            obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);</div><div class="line">        &#125; else &#123;</div><div class="line">            obj[i] = prop;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="-笔试 -美图" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95-%E7%BE%8E%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计(-)</title>
    <link href="http://yoursite.com/2017/04/18/js%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/04/18/js面对对象/</id>
    <published>2017-04-17T16:11:12.000Z</published>
    <updated>2017-04-25T13:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数"><a href="#定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数" class="headerlink" title="定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数"></a>定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数</h4><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><ul>
<li>数据属性  <ul>
<li>[[Configurabke]]:能否通过delete删除属性从而重新定义属性  </li>
</ul>
</li>
<li>访问器属性  </li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="可以通过“构造函数”或者“对象字面量”方法创建函数"><a href="#可以通过“构造函数”或者“对象字面量”方法创建函数" class="headerlink" title="可以通过“构造函数”或者“对象字面量”方法创建函数"></a>可以通过“构造函数”或者“对象字面量”方法创建函数</h4><ul>
<li>缺点：通过一个接口创建很多对象，会产生大量的重复代码  </li>
</ul>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> function creatPerson(name,age,job)&#123;  </div><div class="line">    var o=new Object();  </div><div class="line">    o.name=name;  </div><div class="line">    o.age=age;  </div><div class="line">    o.job=job;  </div><div class="line">    return o  </div><div class="line">&#125;                                                                        </div><div class="line"> var person1 = creatPerson(“hxvin”,21,”F-E”);</div></pre></td></tr></table></figure>
<ul>
<li>用函数来封装以特定接口创建对象的细节  </li>
<li>缺点：没有解决对象识别的问题  </li>
</ul>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">    this.age=age;  </div><div class="line">    this.job=job;  </div><div class="line">    this.sayName=function sayName()&#123;alert(this.name);&#125;;  </div><div class="line">&#125;;  </div><div class="line">var person1=new Person(“hxvin”,21,&quot;Front-end-Engineer&quot;);</div></pre></td></tr></table></figure>
<ul>
<li>和工厂模式的区别：  <ul>
<li>没有显式的创建对象  </li>
<li>直接将属性和方法赋给了this  </li>
<li>没有return语句  </li>
</ul>
</li>
<li>用这种方式调用构造函数会经历一下四个步骤  <ul>
<li>执行构造函数中的代码（为这个新对象添加属性）  </li>
<li>创建一个新对象  </li>
<li>将构造函数的作用域赋给新对象  </li>
<li>返回新对象  </li>
</ul>
</li>
<li><p>缺点：每个方法都要在每个实例上创建一遍  </p>
<ul>
<li><p>上例中sayName方法相当于</p>
<blockquote>
<p>this.sayName=new Funciton(“alert(name,age,job)”)  </p>
</blockquote>
</li>
<li><p>解决方法  </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">    this.age=age;  </div><div class="line">    this.job=job;  </div><div class="line">    this.sayName=sayName  </div><div class="line">&#125;;  </div><div class="line">function sayName()&#123;alert(this.name);&#125;;  </div><div class="line">//将sayName添加到全局变量中，这样显然有很多不足</div></pre></td></tr></table></figure>
<ul>
<li>原型模式  </li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ul>
<li><p>概念  </p>
<ul>
<li><p>每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以<br>  由特定类型的所有实例共享的属性和方法  </p>
</li>
<li><p>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法  </p>
</li>
<li>创建原型:</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  function Person()&#123;&#125;;  </div><div class="line">Person.prototype.name=“hxvin”；  </div><div class="line">Person.prototype.sayname=function()&#123; alert(this.name);  &#125;；                         </div><div class="line">var person1=new Person();                                   </div><div class="line">person1.dayName(); //“hxvin”</div></pre></td></tr></table></figure>
<ul>
<li>理解原型  <ul>
<li>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。  </li>
<li>在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针  </li>
<li>搜索流程  <ul>
<li>当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性  </li>
<li>每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找  </li>
<li>hasOwnProperty()  <ul>
<li>用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true  </li>
<li>alert(person1 hasOwnProperty(“name”));       //返回true或false  </li>
</ul>
</li>
</ul>
</li>
<li>[[prototype]]  <ul>
<li>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象  </li>
<li>利用[[prototype]]  <ul>
<li>ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值  <ul>
<li>支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome  </li>
</ul>
</li>
<li>但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系  <ul>
<li>alert(Person.protoype isPrototypeOf(person1));   //true  </li>
</ul>
</li>
<li>没有标准的方式访问[[prototype]]  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>更简单的原型语法 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> //可以重新设置constructor  </div><div class="line">function Perspn()&#123;&#125;;  </div><div class="line">Person.prototype=&#123;  </div><div class="line">    constructor=Person,  </div><div class="line">    name=&quot;Nick&quot;  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line"> function Person()&#123;&#125;;  </div><div class="line">Person.prototype=&#123;  </div><div class="line">    name=&quot;Nick&quot;,  </div><div class="line">    sayName=function()&#123;alert(this.name)&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数  <ul>
<li>原型的动态性  </li>
<li>注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针）  </li>
<li>我们对原型对象所做的任何修改都能够立即从实例上反映出来  </li>
<li>原型对象的问题（缺点）  </li>
<li>1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值  </li>
<li>2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题）  <ul>
<li>由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;  </div><div class="line">    this.name=name,  </div><div class="line">    this.age=age,  </div><div class="line">    this.job=job  </div><div class="line">&#125;;  </div><div class="line">Person.prototype=&#123;  </div><div class="line">    constructor=Person,  </div><div class="line">    sayName=function()&#123;alert(this.name)&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组  <ul>
<li>优点  </li>
<li>每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存  </li>
<li>创建自定义类型最常见的方式  </li>
<li>支持向构造函数传递参数  </li>
</ul>
</li>
</ul>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;          //属性  </div><div class="line">    this.name=name;  </div><div class="line">    this.age=age;  </div><div class="line">    this.job=job;  </div><div class="line">    //方法  </div><div class="line">    if(typeof sayName != &quot;function&quot;)&#123;  </div><div class="line">        Person.prototype.sayName = function()&#123;alert(this.name)&#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>//方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。<br> 这里对原型所做的修改，能够立即在所有实例中得到反映。  </p>
</blockquote>
<ul>
<li>把所有信息封装在构造函数中，并通过if语句初始化原型  </li>
</ul>
<h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;  </div><div class="line">    var o = new Object();  </div><div class="line">    o.name = name;  </div><div class="line">    o.age = age;  </div><div class="line">    o.job = job;  </div><div class="line">    o.sayName = function()&#123;alert(o.name)&#125;;  </div><div class="line">    return o  </div><div class="line">&#125;;  </div><div class="line">var person1 = new Person();</div></pre></td></tr></table></figure>
<ul>
<li>应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数  </li>
<li>特点  <ul>
<li>返回的对象和构造函数没有关系  </li>
<li>不能依赖instanceof操作符来确定对象类型  </li>
</ul>
</li>
</ul>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><ul>
<li>所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。  </li>
</ul>
<pre><code>function Person(name,age,job){  
      var o = new Object();  
      o.sayName = function(){alert(name)}  
  }  

  var friend = Person (“hxvin”,”21”,”f-e”);  
      friend.sayName(}; //“hxvin”
</code></pre><blockquote>
<p>这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。  </p>
</blockquote>
<ul>
<li>这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。  </li>
<li>应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用  </li>
<li>特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h3&gt;&lt;h4 id=&quot;定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&quot;&gt;&lt;a href=&quot;#定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&quot; class=&quot;headerlink&quot; title=&quot;定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&quot;&gt;&lt;/a&gt;定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&lt;/h4&gt;&lt;h4 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据属性  &lt;ul&gt;
&lt;li&gt;[[Configurabke]]:能否通过delete删除属性从而重新定义属性  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问器属性  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;h4 id=&quot;可以通过“构造函数”或者“对象字面量”方法创建函数&quot;&gt;&lt;a href=&quot;#可以通过“构造函数”或者“对象字面量”方法创建函数&quot; class=&quot;headerlink&quot; title=&quot;可以通过“构造函数”或者“对象字面量”方法创建函数&quot;&gt;&lt;/a&gt;可以通过“构造函数”或者“对象字面量”方法创建函数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;缺点：通过一个接口创建很多对象，会产生大量的重复代码  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h4&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
</feed>
